{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#welcome-to-nimphels-documentation","title":"Welcome to NIMPhEL's documentation","text":"<p>Due to the complex specifications of current electronic systems, design decisions need to be explored automatically. However, the exploration process is a complex task given the plethora of design choices such as the selection of components, number of components, operating modes of each of the components, connections between the components and variety of ways in which the same functionality can be implemented. Nimphel is a generic, open-source framework tackling rapid design exploration for the generation of modular and parametric electronic designs that is able to work on any major simulator.</p> <p>Warning</p> <p>This project is still in development so expect breaking changes. Ideas and contributions are more than welcome.</p>"},{"location":"#citation","title":"Citation","text":"<p>If you use this software, please consider citing the software through the following publication.</p> <p>Vinagrero Guti\u00e9rrez, Sergio, Giorgio Di Natale, and Elena-Ioana Vatajelu. 2023. \"Python Framework for Modular and Parametric SPICE Netlists Generation\" Electronics 12, no. 18: 3970. https://doi.org/10.3390/electronics12183970</p> <p>Or use the following Bibtex source</p> <pre><code>@Article{electronics12183970,\nAUTHOR = {Vinagrero Guti\u00e9rrez, Sergio and Di Natale, Giorgio and Vatajelu, Elena-Ioana},\nTITLE = {Python Framework for Modular and Parametric SPICE Netlists Generation},\nJOURNAL = {Electronics},\nVOLUME = {12},\nYEAR = {2023},\nNUMBER = {18},\nARTICLE-NUMBER = {3970},\nURL = {https://www.mdpi.com/2079-9292/12/18/3970},\nISSN = {2079-9292},\nDOI = {10.3390/electronics12183970}\n}\n</code></pre>"},{"location":"#documentation-structure","title":"Documentation structure","text":"<p>This documentation is structured in the following way:</p> <ul> <li>The getting started section describes the rationale, installation instructions and road map of this project.</li> <li>In the core section, the main mechanics and utilities are described.</li> <li>How to read netlists and serialize circuits is described in the parsing.</li> <li>How to serialize and export circuits to different formats and SPICE specifications is described in the exporting.</li> <li>Some use cases of this project are displayed in the last section.</li> </ul>"},{"location":"core/","title":"Core","text":"<p>This section will show the different. It is important to state that since this framework is still in development, some mechanisms and classes could change in the future.</p> <p>Note</p> <p>Although this framework is simulator agnostic, the next examples will be focused for the Spectre simulator.</p>"},{"location":"core/#spice-directives","title":"SPICE Directives","text":"<p>Directives refer to raw SPICE statements normally used to control the simulator. Directives need to be added to a circuit object to be added in the netlist.</p> <p>Directives are created through the <code>Directive</code> class and can be created in 2 ways:</p> <ul> <li>A single string containing the raw directive</li> <li>The directive name and a dictionary containing the parameters of the directive. Usually, directives are formatted as <code>name param1=value param2=value ...</code>, depending on the simulator used.</li> </ul> <p>When supplying a dictionary with the parameters of the directive, the value <code>None</code> can be used to indicate that a parameter should only use the key instead of the key value pair. The following examples show the different ways of definining directives.</p> Creating directives<pre><code>from nimphel import Directive, Circuit\n# Raw string directive\nDirective(\"global 0 gnd\")\n# global 0 gnd\n# Directive with parameters\nDirective(\"simulator\", {\"lang\": \"spectre\"})\n# simulator lang=spectre\n# The info parameter is None\nDirective(\n\"modelParameter\",\n{\"info\": None, \"what\": \"models\", \"where\": \"rawfile\"}\n)\n# modelParameter info what=models where=rawfile\n# Adding a directive to a circuit\nd = Directive(\"global 0 gnd\")\ncircuit = Circuit()\ncircuit.add(d)\n</code></pre> <p>It is important to keep in mind that directives are always created as the name and the dictionary of parameters when reading a circuit from a netlist file.</p>"},{"location":"core/#instances","title":"Instances","text":"<p>Instances are one the the core constituents of SPICE and therefore this framework. As the name implies, they refer to specific instances of electronic components inside a SPICE netlist. The way instances are described depends on the SPICE specificiation used, but they usually follow this structure.</p> Instance in SPICE format<pre><code>M1 (GND VDD) NMOS vth=1.0\n</code></pre> <p>In nimphel, the previous instance would be created in the following manner:</p> Creating a simple instance<pre><code>from nimphel import Instance, Circuit\ninst = Instance(\nname=\"NMOS\", nodes=[\"GND\", \"VDD\"],\nparams={\"vth\": 1.0}, cxt=None,\ncap=\"M\", uid=1, metadata=None\n)\nCircuit().add(inst)\n</code></pre> <p>The <code>ctx</code> keyword allows defining the context under which an instance is created. If an instance is created at the top level (e.g. directly in the circuit) it defaults to <code>None</code>. However, when an instance is created as part of a subcircuit, the context is the name of the subcircuit. This allows us to create sort of a dependency graph of each of the components and subcircuits.</p> <p>The metadata contains a dictionary of values that can be useful when translating components from and to different tools. By default, all instances have no metadata.</p> <p>Instances can also be copied and modified once they have been created.</p> Copying and updating an instance<pre><code>nmos = Instance(\nname=\"NMOS\", nodes=list(\"DGSB\"),\nparams={\"vth\": 1.0}, cxt=None,\ncap=\"M\", uid=1, metadata=None\n)\npmos = nmos.copy()\npmos.name = \"PMOS\"\npmos.params[\"vth\"] = -1.0\n</code></pre> <p>However, creating instances in this way can become cumbersome very quickly, specially if we are instanciating the same electronic component multiple times. The following section shows how to create components to allow creating multiple instances of the same component in a simple and reusable manner.</p>"},{"location":"core/#components","title":"Components","text":"<p>Components in nimphel can be seen as instance generators for a desired electronic component. To create instances of the same type of component, a <code>Component</code> object needs to be created, that will be later used to create new instances. A <code>Component</code> needs the following parameters:</p> <ul> <li>The component name (e.g. resistor, capacitor, nmos, ...)</li> <li>A list containing the names of the nodes. The order is important when exporting to an actual netlist.</li> <li>A dictionary of default parameters. If not default parameters can be set up, an empty dictionary should be passed.</li> </ul> Creating a component<pre><code>from nimphel import Component\n# No default parameters\nnmos = Component(\"nmos\", list(\"DGSB\"), {})\n# Width and length as default parameters\npmos = Component(\"pmos\", list(\"DGSB\"), {\"w\": 65e-9, \"l\": 100e-9})\n</code></pre>"},{"location":"core/#creating-instances","title":"Creating Instances","text":"<p>Once a component has been generated, it can be directly used to spawn new instances. Each instance can be generated and customized in various ways. The following example provides some of the ways of generating instances of the <code>nmos</code> and <code>pmos</code> components that have been created in the previous example.</p> Creating instances from a component<pre><code>from nimphel import Component\nnodes = [\"Drain\", \"Gate\", \"Source\", 0]\n# Update the default parameters\npmos.new(nodes, params={'w': 30e-9})\n# Instance(\n#   name='nsvtlp',\n#   nodes=[\"Drain\", \"Gate\", \"Source\", 0],\n#   params={'w': 30e-9, 'l': 100e-9},\n#   ctx=None, cap=None, uid=None, metadata={}\n# )\n# Use only the parameter supplied\npmos.new(nodes, params={'w': 30e-9}, force=True)\n# Instance(\n#   name='nsvtlp',\n#   nodes=[\"Drain\", \"Gate\", \"Source\", 0],\n#   params={'w': 30e-9},\n#   ctx=None, cap=None, uid=None, metadata={}\n# )\n# Add a context to the instance\npmos.new(nodes, ctx=\"Subcircuit name\")\n# Instance(\n#   name='nsvtlp',\n#   nodes=[\"Drain\", \"Gate\", \"Source\", 0],\n#   params={'w': 65e-9, 'l': 100e-9},\n#   ctx=\"Subcircuit name\", cap=None, uid=None, metadata={}\n# )\n# Add metadata\npmos.new(nodes, metadata={'should_export': False})\n# Instance(\n#   name='nsvtlp',\n#   nodes=[\"Drain\", \"Gate\", \"Source\", 0],\n#   params={'w': 65e-9, 'l': 100e-9},\n#   ctx=None, cap=None, uid=None,\n#   metadata={'should_export': False}\n# )\n# Create an instance with a desired uid\npmos.new(nodes, uid=42)\n# Instance(\n#   name='nsvtlp',\n#   nodes=[\"Drain\", \"Gate\", \"Source\", 0],\n#   params={'w': 65e-9, 'l': 100e-9},\n#   ctx=None, cap=None, uid=42, metadata={}\n# )\n</code></pre> <p>The instance nodes can also be supplied as keyword argumets at the beginning of the <code>new</code> method. However, the instance parameters always need to be precedded by the <code>params</code> keyword.</p> Nodes as keyword arguments<pre><code>pmos.new(D=\"Drain\", G=\"Gate\", S=\"Source\", B=0, params={'w': 30e-9})\n# Nodes can be supplied in any order\npmos.new(B=0, S=\"Source\", G=\"Gate\", D=\"Drain\")\n</code></pre> <p>If the number of nodes supplied to <code>new</code> does not match with the ones defined in the component, a <code>NodesError</code> exception is raised.</p> Creating instances from a component<pre><code>try:\npmos.new([0])\nexcept NodesError:\nprint(\"We only supplied 1 node\")\n</code></pre> Creating a component from an instance<pre><code>from nimphel import Component\npmos = Component(\"pmos\", list(\"DGSB\"), {})\npmos_new = Component.from_instance(pmos.new([1, 2, 3, 0]))\nassert pmos == pmos_new\n</code></pre>"},{"location":"core/#models","title":"Models","text":"<p>Models are a 1 to 1 equivalence of SPICE models. They allow creating new components that inherit from some other components while having different model parameters. The following example shows how to create a model <code>MOD1</code> that inherits from <code>NPN</code>.</p> SPICE model declaration<pre><code>model MOD1 NPN (BF=50 IS=1E-13 VBF=50)\n</code></pre> Creating a model<pre><code>m = Model(\"MOD1\", \"NPN\", {'BF': 50, 'IS': 1e-13, 'VBF': 50})\n</code></pre>"},{"location":"core/#subcircuits","title":"Subcircuits","text":"<p>A subcircuit is nimphel is also a 1 to 1 translation of SPICE subcircuits. They allow grouping a number of instances under in order to create a reusable component. Subcircuits, differently from components, need to be registered in a circuit for the simutator to keep track of the different components. This can be accomplished through the <code>add</code> method on a <code>Circuit</code> object.</p> <p>The way to build a <code>Subcircuit</code> is almost identical to building a <code>Component</code>:</p> <ul> <li>The name of the subcircuit</li> <li>The list of nodes</li> <li>The parameters of the subcircuit</li> </ul> Registering a subcircuit<pre><code>from nimphel import Subcircuit\ninv = Subcircuit(\"INV\", [\"in\", \"out\", \"vdd\", \"gnd\"], {})\n# Adding instances to the subcircuit\ninv.add(pmos.new())\ninv.add(nmos.new())\n# The subcircuit is registered with the 2 instances\ncircuit.add(inv)\n# These changes won't be seen by the circuit\ninv.add(pmos.new())\n</code></pre> <p>We can create a <code>Component</code> from a subcircuit in order to create instances and prevent us from modifying the subcircuit. This is performed through the <code>Component.from_subcircuit</code> method.</p> Creating a component from a subcircuit<pre><code>comp = Component.from_subcircuit(inv)\n</code></pre> <p>We can perform parameter substitution of the instances of a subcircuit by using the <code>subs</code> method.</p> Parameter substitution<pre><code>inv = inv = Subcircuit(\"INV\", [\"in\", \"out\", \"vdd\", \"gnd\"], {\"w_inv\": None})\ninv.add(nmos.new(nodes, {'w': 0.4}))\ninv_new = inv.subs(w=\"w_inv\")\n</code></pre>"},{"location":"core/#circuits","title":"Circuits","text":"<p>In nimphel, circuits are the main interface with SPICE netlists. Directives, Instances and Subcircuits are added to a circuit through the <code>add</code> method. A list of elements can be registered in one time by supplying the list directly. </p> <p>The <code>add</code> method is also overloaded as the <code>+</code> operator which creates a new copy of the circuit and the <code>+=</code> operator which modifies in place.</p> Creating a circuit<pre><code>from nimphel import Circuit\ncircuit = Circuit()\ncircuit.add(Directive(...))\ncircuit.add(Instance(...))\ncircuit.add(Subcircuit(...))\ncircuit.add([Instance(...) for i in range(100)])\n</code></pre> <p>The following section will show how to parse SPICE netlists to automatically create circuits and write these circuits to a plethora of SPICE specifications or user defined formats.</p>"},{"location":"manipulation/","title":"Manipulation","text":"<p>The manipulation of components is one of the key features of nimphel. Nimphel makes use of the basic mathematical operators to manipulate components.</p>"},{"location":"manipulation/#chain","title":"Chain","text":"<p>Chained components start in the component input and generate a chain where the input of a new component is the output of the previous one. The operator <code>*</code> is used to chain components.</p> <p>The ports of chained components follow this behaviour: <pre><code>(in, out) -&gt; (out, net()) -&gt; ... (net(), net())\n</code></pre></p> Example of chained components<pre><code>Res = R([GND, net()])\nnetlist.add(Res * 3)\n# Will produce 3 resistances with the ports:\n# (GND, 1), (1, 2), (2, 3)\n</code></pre> <p>A component can also be chained by using a tuple containing the fields <code>(num components, last net name)</code> as follows:</p> Chained components with named output<pre><code>Res = R([GND, net()])\nnetlist.add(Res * (3, \"OUT\"))\n# Will produce 3 resistances with the ports:\n# (GND, 1), (1, 2), (2, \"OUT\")\n</code></pre>"},{"location":"manipulation/#parallel","title":"Parallel","text":"<p>Components in parallel share the same input and output. The operator <code>|</code> is used to create components in parallel.</p> <p>The ports of components in parallel follow this behaviour: <pre><code>(in, out) -&gt; (in, out) -&gt; ... (in, out)\n</code></pre></p> Example of components in parallel<pre><code>Res = R([GND, net()])\nnetlist.add(Res | 3)\n# Will produce 3 resistances with the ports\n# (GND, 1), (GND, 1), (GND, 1)\n</code></pre>"},{"location":"manipulation/#self-loop","title":"Self loop","text":"<p>A self loop creates a copy of the component and reverses the order of the ports, that is, input is connected to output and viceversa. The operator <code>~</code> is used to create self loops.</p> <p>The ports of components in self loop follow this behaviour: <pre><code>(in, out) -&gt; (out, in)\n</code></pre></p> Example of self looped components<pre><code>Res = R([GND, net()])\nnetlist.add(~Res)\n# Will produce 2 resistances with the ports\n# (GND, 1), (1, GND)\n</code></pre>"},{"location":"manipulation/#fan-out","title":"Fan out","text":"<p>Components in fan out share the same input but have a different output port each. The operator <code>^</code> is used to create fan outs.</p> <p>The ports of components in fan out follow this behaviour: <pre><code>(in, out) -&gt; (in, net()) -&gt; ... (in, net())\n</code></pre></p> Example of components in fan out<pre><code>Res = R([GND, net()])\nnetlist.add(Res ^ 3)\n# Will produce 3 resistances with the ports\n# (GND, 1), (GND, 2), (GND, 3)\n</code></pre>"},{"location":"manipulation/#direct","title":"Direct","text":"<p>Components that are directed, have the same output but have a different input each. It's behaviour is the opposite of <code>fan out</code>. The operator <code>&amp;</code> is used to create self loops.</p> <p>The ports of components in fan out follow this behaviour: <pre><code>(in, out) -&gt; (net(), out) -&gt; ... (net(), out)\n</code></pre></p> Example of directed components.<pre><code>Res = R([GND, net()])\nnetlist.add(Res &amp; 3)\n# Will produce 3 resistances with the ports\n# (2, 1), (3, 1), (4, 1)\n</code></pre>"},{"location":"manipulation/#complex-manipulation","title":"Complex manipulation","text":"<p>For components that are more complex, there are methods to perform the manipulations. The ports for chains are defined using masks, that is, a tuple whose non null positions mark the number of ports to manipulate. </p> <p>As an example, we cannot chain a Mosfet Mosfet since the chain will be done with the ports \"out\" and \"GND\". We need to define the chain using the first and second port.</p> <pre><code>m = Mosfet([\"out\", \"in\", GND, GND], name=\"nmos\")\nm.chain((1, 1, 0, 0), 3)\nm.parallel((1, 1, 0, 0), 3)\nm.self_loop((1, 1, 0, 0), 3)\nm.fanout((1, 1, 0, 0), 3)\nm.direct((1, 1, 0, 0), 3)\n</code></pre>"},{"location":"manipulation/#getting-ports","title":"Getting ports","text":"<p>In order to create connections between components that have been manipulated, there are two functions: <code>port_getter</code> and <code>port_setter</code>.</p> Example of getting ports<pre><code>chains = CustomSubckt.inst([\"INPUT\", \"OUT\"], {}) ^ 3\nchains_out = port_getter(chains, (0, 1), flatten=True)\n</code></pre> <p>The argument <code>flatten</code> removes null values from the ports and returns a tuple containing just the values of the ports requested.</p> Usage of the flatten argument<pre><code>chains_out = port_getter(chains, (0, 1), flatten=False)\n# chains_out = [(0, 1), (0, 2), (0, 3)]\nchains_out = port_getter(chains, (0, 1), flatten=True)\n# chains_out = [(1,), (2,), (3,)]\n</code></pre>"},{"location":"manipulation/#setting-ports","title":"Setting ports","text":"<p>The function <code>port_setter</code> allows to set the ports of a list of components. It receives a list of components and a list of masks, whose values correspond to the final ports of each component</p> Example of setting ports<pre><code># Components is a list of 3 components with two ports\nmask = [(\"INPUT\", \"OUT_1\"), (\"INPUT\", \"OUT_3\"), (\"INPUT\", \"OUT_3\")]\nport_setter(components, mask)\n</code></pre>"},{"location":"manipulation/#1d-and-2d-arrays","title":"1D and 2D Arrays","text":"<p>Components that follow a 1D or 2D configuration can be instanciated by using the function <code>make_array</code>. This function takes 3 arguments.</p> <ul> <li>Tuple containing the 1D or 2D dimensions of the array. <ul> <li>For 2D arrays, the coordinates are given as <code>(Y, X)</code></li> <li>For 1D arrays the dimension <code>(Y,)</code> represents the length of the array.</li> </ul> </li> <li>The component instance that will be used to fill the array.</li> <li>If provided, a function whose input is the coordinates of the component returns the ports of that component.</li> </ul> Generating a 1D array of resistances<pre><code>def ports_res(p):\nreturn [f'X_{c[0]}', GND]\narr = make_array((5, ), R([\"\", \"\"]), ports_fn=ports_res)\nnetlist.add(arr)\n</code></pre> Generating a 2D array of resistances<pre><code>def ports_res(p):\nx, y = p\nreturn [f\"Y_{y}\", f\"X_{x}\"]\narr = array((3, 5), R([\"\", \"\"]), ports_fn=ports_res)\nnetlist.add(arr)\n</code></pre> <p>The array is created by using numpy, so we have access to numpy tools.</p> Printing an array of components.<pre><code>for y, x in np.ndindex(m.shape):\nprint(arr[y, x])\n</code></pre>"},{"location":"manipulation/#complex-example","title":"Complex example","text":"Creation of a RO PUF.<pre><code>class Mosfet(Component):\ndef __init__(self, ports: Ports, params: Optional[Params] = None, name=None):\nparameters = params if params else {}\nsuper(Mosfet, self).__init__(\nports, parameters, model=NMOS, name=name, letter=\"M\"\n)\n@simple_component\nclass VCounter(Component):\n\"\"\"Verilog A Counter\"\"\"\nname = \"counter\"\nletter = \"I\"\nmodel = models[\"counter\"]\n@simple_component\nclass C(Component):\ndefaults: Params = {\"C\": 1e3, \"T\": None}\ninv = Subckt(\n\"INV\",\n[\"vdd\", \"gnd\", \"in\", \"out\"],\n{\"vthp\": None, \"vthn\": None, \"lp\": 0.06, \"ln\": 0.06},\n)\ninv.add(Mosfet([\"out\", \"in\", GND, GND], name=\"nsvtlp\"))\ninv.add(Mosfet([\"out\", \"in\", VDD, VDD], name=\"psvtlp\"))\ninv.fix()\nand_gate = Circuit()\nout_and = net()\nand_gate.add(Mosfet([\"A\", VDD, \"OUT\", VDD], name=\"psvtlp\"))\nand_gate.add(Mosfet([\"B\", VDD, \"OUT\", VDD], name=\"psvtlp\"))\nand_gate.add(Mosfet([\"B\", \"OUT\", out_and, GND], name=\"nsvtlp\"))\nand_gate.add(Mosfet([\"A\", out_and, GND, GND], name=\"nsvtlp\"))\nAND_GATE = and_gate.into_subckt(\"AND\", [\"A\", \"B\", \"OUT\"], {})\nnetlist.add(AND_GATE.inst([net(), net(), net()]))\nN_RO_PER_CHAIN = 5\nN_CHAINS = 3\nMUX = Subckt(\"MUX\", [f\"IN_{d}\" for d in range(N_CHAINS)] + [\"Sel\", \"OUT\"], {})\nINV = Subckt(\"INV\", [\"in\", \"out\"], {})\nINV.add(Mosfet([\"out\", \"in\", GND, GND], name=\"nsvtlp\"))\nINV.add(Mosfet([\"out\", \"in\", VDD, VDD], name=\"psvtlp\"))\nINV.fix()\ninv = INV.inst([\"in_chain\", net()], {})\nchain = Circuit()\nchain.add(inv * (N_RO_PER_CHAIN, \"OUT\"))\nro_chain = chain.into_subckt(\"RO_CHAIN\", [\"in_chain\", \"OUT\"], {})\nchains = ro_chain.inst([\"INPUT\", \"OUTStable\"], {}) ^ N_CHAINS\nchains_out = port_getter(chains, (0, 1), flatten=True)\nnetlist.add(chains)\ncounters = VCounter([\"\"]) | N_CHAINS\nport_setter(counters, chains_out)\nnetlist.add(counters)\n</code></pre>"},{"location":"old/","title":"Parameters","text":"<p>Parameters are a set of phisical properties of a component</p> <pre><code>params = Params({'width': 0.6, 'length': 0.25})\n</code></pre> <p>Every time a parameter object is called, it generates a new set of values based on the formulas defined. If no formulas are used, the same object is returned.</p> <pre><code>from random import uniform\nparams = Params({'width': 0.6, 'length': uniform(0, 1)})\nprint(params)\n# Prints Params({\"w\": 0.6, \"l\": \"fn()\"}))\nfixed = params()\nprint(params)\n# Prints Params({\"w\": 0.3, \"l\": \"0.3\"}))\n</code></pre>"},{"location":"old/#models","title":"Models","text":"<p>Models allow to group parameters under a name to be reusable</p> <pre><code>model = Model(\"MY_MODEL\", params = params)\nfixed = model()\nprint(fixed)\n# Prints Params({\"w\": 0.3, \"l\": \"0.3\"}))\n</code></pre>"},{"location":"old/#component","title":"Component","text":""},{"location":"old/#subcircuits","title":"Subcircuits","text":""},{"location":"old/#circuits","title":"Circuits","text":""},{"location":"old/#manipulation","title":"Manipulation","text":"<p>Manipulations are the main tool of nimphel.</p> <p>They are monads that hold some manipulations.</p>"},{"location":"old/#basic-manipulation","title":"Basic manipulation","text":""},{"location":"old/#parallel","title":"Parallel","text":"<pre><code>res = Component(\"Mosfet\", [\"GND\", \"VDD\"])\nelems = res | 5\n# Elems is a Manip with the contents\n# Component(Res ['VDD', 'GND'] Params({\"w\": 0.3, \"l\": \"fn()\"}))\n# Component(Res ['VDD', 'GND'] Params({\"w\": 0.3, \"l\": \"fn()\"}))\n# Component(Res ['VDD', 'GND'] Params({\"w\": 0.3, \"l\": \"fn()\"}))\n# Component(Res ['VDD', 'GND'] Params({\"w\": 0.3, \"l\": \"fn()\"}))\n# Component(Res ['VDD', 'GND'] Params({\"w\": 0.3, \"l\": \"fn()\"}))\n</code></pre>"},{"location":"old/#chains","title":"Chains","text":"<pre><code>mos = Component(\"Mosfet\", [\"GND\", \"VDD\", net(), net()])\nelems = mos | 5\n</code></pre> <p>For components with more than 2 ports, a position mask can be supplied</p> <pre><code>mos = Component(\"Mosfet\", [\"GND\", \"VDD\", net(), net()])\nelems = mos * (5, (None, None, Port.IN, Port.OUT))\n</code></pre>"},{"location":"old/#complex-manipulation","title":"Complex manipulation","text":"<p>As it has been said earlier, manipulations are just monads.</p> <pre><code>def freeze_params(comp):\ncomp.params = Params(comp.params())\nreturn comp\n</code></pre> <p>We want to apply this function to every element of a manipulation <pre><code>res = Component(\"Res\", ['GND', 'VDD'])\nelements = res | 10\nelements = elements.apply(freeze_params, *args, **kwargs)\nelements = elements @ freeze_params\nelements &lt;&lt;= freeze_params\n</code></pre></p>"},{"location":"old/#bind","title":"Bind","text":"<p>Example injecting defects in a chain of inverters</p> <pre><code>def inject_defects(elems, p=0.5, defect=None):\ndefect = defect or Component(\"Cap\", [\"\", \"GND\"])\nnew_elems = []\nfor comp in elems:\nif random.random() &lt;= p:\nnew_elems.append(defect % [comp.ports[-1], None])\nnew_elems.append(c)\nreturn new_elems\n</code></pre> <pre><code>inv = Component(\"Inv\", ['VDD', 'GND', net(), net()])\nchain = inv * 5\nchain = chain.bind(inject_defects, p = 0.3)\nchain = chain ** inject_defects\nchain &gt;&gt;= inject_defects\n</code></pre>"},{"location":"old/#chaining-manipulations","title":"Chaining manipulations","text":"<p>It is important to mention that the bind and apply operations can be chained together either with their respective methods or with the <code>**</code> and <code>@</code> operators. The apply <code>&lt;&lt;=</code> and bind <code>&gt;&gt;=</code> operators are non chainable and thus need to be in a different line each.</p> <pre><code>chain = chain.bind(inject_defects, p = 0.3).apply(freeze_params)\n# Careful with other of priorities\nchain = chain ** inject_defects @ freeze_params\n# This is executed as\n# chain = (chain ** inject_defects) @ freeze_params\nchain &gt;&gt;= inject_defects\nchain &lt;&lt;= freeze_params\n</code></pre>"},{"location":"old/#circuits_1","title":"Circuits","text":""},{"location":"parsers/","title":"Parsing netlists","text":"<p>Parsers allow reading a set of SPICE text formats and convert them into nimphel <code>Circuits</code>. Parsing is performed thanks to the Lark library.</p>"},{"location":"parsers/#parsing-spice-netlists","title":"Parsing SPICE netlists","text":"<p>In order to parse a netlist, a <code>Reader</code> object needs to be created first. A reader needs a Lark grammar and a transformer. Nimphel already comes with some predefined grammars. </p> <p>As of today the following parsers are implemented: <code>Spectre</code>.  More grammars and parsers will be added in the future.</p> <p>Info</p> <p>These grammars can be found in the <code>*.lark</code> files inside the <code>reader</code> directory.</p> <p>The following examples shows how to create a <code>Reader</code> object and use it to parse a netlist file or a string.</p> Parsing a netlist<pre><code>from nimphel.reader import Reader\nparser = Reader(\"grammar\")\n# Parse a netlist file\ncircuit = reader.read(\"/path/to/netlist\")\nnetlist = \"\"\"\nM0 (0 1) R R=100k\n...\n\"\"\"\n# Parse a string\ncircuit = reader.reads(netlist)\n</code></pre> <p>If the parsing was unsuccessful, the reader will return <code>None</code> and will print the exception. The following exceptions can be raised during parsing:</p> <ul> <li><code>UnexpectedEOF</code>: Raised if unexpected end of file is found.</li> <li><code>UnexpectedToken</code>: Raised if an unexpected token is found.</li> <li><code>UnexpectedCharacters</code>: Raised if an unexpected character is found when parsing.</li> </ul> <p>Lark allows creating custom <code>Transformers</code> that will take a tree (what lark parses) into a new tree where each component has been modified by an user defined function. It can be used for instance to parse text and create python objects directly. To specify the transformer used, provide the <code>transformer</code> parameter along with the transformer class. Nimphel already includes the transformer <code>ToCircuit</code> that will automatically create a circuit with instances, subcircuit definitions and SPICE directives.</p> <p>To know more about transformers, please refer to the official documentation.</p> Specifying a transformer when parsing<pre><code>reader = Reader(\"spectre\", transformer=CustomTransformer)\ncustom_circuit = reader.read(\"/path/to/netlist\")\n</code></pre>"},{"location":"parsers/#deserializing-circuits","title":"Deserializing circuits","text":"<p>SPICE netlists are the base format of all SPICE simulators, but sometimes we may like to interface with some tools that do not understand this format. To solve this issue, we can create a custo reader class that overloads the <code>reads</code> and <code>read</code> method to deserialize data into a circuit object.</p> <p>The following example shows how to create a <code>JsonReader</code> that will deserialize a circuit from a JSON file and create the resulting circuit. Since this reader overrides the <code>read</code> method, it should also take care of Exceptions that the deserializing process may raise.</p> Defining a custom deserializer<pre><code>import json\nclass JsonReader(Reader):\ndef read(self, path):\nwith open(path, \"r\") as fp:\ncontent = json.load(fp)\nreturn Circuit(**content)\ncircuit = JsonReader().read(\"/path/to/circuit.json\")\n</code></pre>"},{"location":"starting/","title":"Getting started","text":""},{"location":"starting/#rationale","title":"Rationale","text":"<p>This framework was originally conceived from a set of utility functions designed to generate a SPICE netlist while altering the parameters of the different components as a way to bypass the limitations of some simulators when running process variability simulations at large scale. From these tools, this framework was conceived to provide an interface to SPICE that was as frictionless and simple as possible for other people to adapt and use while being powerful enough to generate modular and reusable circuits with ease. </p> <p>Traditionally, scripts or custom software have been used to generate complicated SPICE netlists. However, most of these solutions are not available to the public are ad-hoc and thus serve no other purpose for other circuits. This framework provides tools to create subcircuits or certain instances from another tool (e.g. Cadence), parse the netlist and modify it (for example to perform process variability simulations) or extend it by creating the circuit depending on a user defined configuration (aka a macro compiler for SRAM, MACs, chains, ...). As such, it was not designed to substitute the commercially available CAD tools, rather boost the design, simulation cycle.</p>"},{"location":"starting/#road-map","title":"Road map","text":"<p>This framework was conceived originall from a set of functions and scripts. While it has been extended to supply most of the creator's needs, there are some objectives to extend this project. The following list provides some of the objectives that may (or not) be implemented.</p> <p>Issues, ideas and contributions are more than welcome.</p> <ul> <li>Support for more standards and formats.</li> <li>Support for working with SPICE libraries (Corners, parameters and component definitions)</li> <li>Automatic layout generation (Perhaps infeasible)</li> </ul>"},{"location":"starting/#installation","title":"Installation","text":"<p>Nimphel can be installed by running the following commands.</p> Installation instructions<pre><code>$ git clone https://github.com/servinagrero/nimphel &amp;&amp; cd nimphel\n$ poetry install &amp;&amp; poetry build\n$ pip install .\n</code></pre>"},{"location":"usage/","title":"Use cases","text":"<p>This section provides a small list of real life use cases that nimphel was designed to solve.</p>"},{"location":"usage/#process-variability","title":"Process variability","text":"<p>As it was stated in the rationale, this project started from a set of utility functions and scripts to perform parametric analysis at large scale.</p> <p>Since component and instance parameters can be manipulated with python dictionaries, process variability comes basically for free.</p> Example of process variability<pre><code>from nimphel import Circuit, Component\nfrom nimphel.writer import SpectreWriter\nfrom nimphel.reader import Reader\nimport random\ncircuit = Reader(\"spectre\").read(\"/path/to/netlist_template\")\n# We want to modify the next component\n# mos = Component(\"nmos\", [\"D\", \"G\", \"S\", \"GND\"], {})\nW_NOM = 65e-9\nL_NOM = 100e-9\ndef params():\nreturn {\n\"w\": random.gauss(W_NOM, 0.1 * W_NOM),\n\"l\": random.gauss(L_NOM, 0.1 * W_NOM),\n}\nfor inst in circuit.instances:\nif inst.name != \"nmos\":\ncontinue\nupdated = params()\ninst.params = {**inst.params, **updated}\nwriter = SpectreWriter()\nprint(writer.writes(circuit))\n</code></pre>"},{"location":"usage/#chain-of-components","title":"Chain of components","text":"Example of a chain of components<pre><code>from nimphel.core import Component, Circuit\ncircuit = Circuit()\nR = Component(\"resistor\", [\"GND\", \"VDD\"], {\"R\": 1e3})\nchain_length = 42\nfor i in range(chain_length):\nstart, end = i, i+1\ninst = R.new([start,end], params={\"R\": 1e3 * i})\ncircuit.add(inst)\n</code></pre> Using a list comprehension<pre><code>from itertools import pairwise\npairs = enumerate(pairwise(range(chain_length), 1)\nchain = [R.new([f,s], params={\"R\": 1e3 * i}) for i, (f,s) in pairs]\ncircuit.add(chain)\n</code></pre> <p>Both of the examples above produce the following SPICE netlist. We can see from this example that we can easily parametrize the structure of the chain, since we can define the length of the chain and create a different instance at every index of the chain.</p> Generated SPICE netlist<pre><code>M0 (0 1) resistor R=1k\nM1 (1 2) resistor R=2k\nM2 (2 3) resistor R=3k\nM3 (3 4) resistor R=4k\n...\nM41 (41 42) resistor R=42k\n</code></pre>"},{"location":"usage/#2d-array-of-components","title":"2D array of components","text":"Example creating a 2D array<pre><code>for x in range(n):\nfor y in range(n):\ncomp.new([x, y])\n# Reduced version\nfrom itertools import product\ncoords = product(range(n), range(m))\nmatrix = [comp.new([x, y]) for x, y in coords]\n</code></pre>"},{"location":"writers/","title":"Writers","text":"<p>Writers allow the conversion of a circuit into a plethora of text formats to use the same circuit under different SPICE implementations. Although writers are focused on outputing SPICE netlists files, they can be used to export a Circuit to any user defined text format. Although writers are focused on exporting circuits to different SPICE specifications, they can be overloaded to serialized circuits to different formats (e.g. JSON, YAML, pickle, ...)</p>"},{"location":"writers/#exporting-a-circuit","title":"Exporting a circuit","text":"<p>Once a circuit has been generated, it can be exported to a string, and consequently to a file, by using the provided <code>Writer</code> class. The method <code>writes</code> converts the circuit into a string, while the <code>writes</code> method writes the string directly to the file given the path.</p> Exporting a circuit<pre><code>writer = CustomWriter()\n# Write the circuit into a string\nres = writer.writes(circuit)\n# Write the circuit directly into a file\nwriter.write(circuit, \"/path/to/file\")\n</code></pre>"},{"location":"writers/#custom-writers","title":"Custom Writers","text":"<p>As of today, the following writers are implemented: <code>Spectre</code>, <code>Xyce</code>.</p> <p>However, more writers can be implemented easily by creating a class that inherits from the <code>Writer</code> class. To define the format for a given object (instance, subcircuit, directive, ...) the user needs to implement a method whose name corresponds to the desired object. If a method is not implemented for a given type of object, the <code>Writer</code> will use the <code>__default__</code> method that outputs the string representation of the object. This method can also be overwritten.</p> Defining a custom writer<pre><code>class CustomWriter(Writer):\ndef instance(self, o):\nrepr(o)\ndef subcircuit(self, o):\nreturn f\"subckt {o.name} {o.nodes}\\n\" f\"ends {o.name}\"\ndef directive(self, o):\nreturn f'{o.name}'\n</code></pre> <p>Once a writer has been defined, the user needs to create an instance and call either the <code>writes</code> or <code>write</code> method. The first one, outputs circuit converted into a string, while the latter writes the string directly into the supplied path.</p> Exporting a circuit<pre><code>writer = CustomWriter()\n# Write the circuit to a string\nnetlist = write.writes(circuit)\n# Write directly to a file\nwrite.write(circuit, \"/path/to/netlist\")\n</code></pre>"},{"location":"writers/#deserializing-a-circuit","title":"Deserializing a circuit","text":"<p>Writers allow converting a circuit into a plethora of SPICE formats or user defined text formats. However, a problem arises when we want to serialize a circuit into a given format (e.g JSON). This can be achieved by overwriting the <code>writes</code> method to directly serialize the object to the given format. As the <code>write</code> method automatically calls <code>writes</code> it may not be necesary to override both methods.</p> <p>The deserialization process is described in detail in the parsing section</p> <p>The following example shows how to serialize a circuit into the JSON format. In this case, creasing a custom class just to call the <code>json.dumps</code> method is a bit convoluted, but it shows that is possible to preprocess a circuit before the serialization.</p> Creating a JSON serializer<pre><code>import json\nclass JsonWriter(Writer):\ndef writes(self, o):\nreturn json.dumps(dict(o))\n</code></pre>"},{"location":"elements/circuit/","title":"Circuit","text":"<p>A <code>circuit</code> is a top level object. It allows the aggregation of multiple components.</p> <p>The main difference between a subcircuit and a circuit is that the circuit also holds the definition of the subcircuits it contains.</p>"},{"location":"elements/circuit/#creating-a-subcircuit","title":"Creating a subcircuit","text":"<p>A circuit can be converted into a subcircuit by using the <code>into_subckt</code> method.</p> Example of creating an AND gate<pre><code>and_gate = Circuit()\nout_and = net()\nand_gate.add(Mosfet([\"A\", VDD, \"OUT\", VDD], name=\"pmos\"))\nand_gate.add(Mosfet([\"B\", VDD, \"OUT\", VDD], name=\"pmos\"))\nand_gate.add(Mosfet([\"B\", \"OUT\", out_and, GND], name=\"nmos\"))\nand_gate.add(Mosfet([\"A\", out_and, GND, GND], name=\"nmos\"))\nAND_GATE = and_gate.into_subckt(\"AND\", [\"A\", \"B\", \"OUT\"], {})\n# Now we can create instances of AND_GATE\n# gate = AND_GATE.inst([net(), net(), net()], {})\n</code></pre>"},{"location":"elements/circuit/#global-circuit","title":"Global circuit","text":"<p>There is a global circuit called <code>netlist</code> that exists within nimphel. This circuit behaves as the main SPICE netlist. Component ids always refer to the global netlist.</p>"},{"location":"elements/circuit/#dependency-graph","title":"Dependency graph","text":"<p>A dependency graph holds the different subcircuits and components that make up a circuit and the relationships between them.</p> <pre><code>graph = netlist.to_graph()\ngenerate_graph(graph)\n# To view the graph we need to import some libraries\nimport matplotlib.pyplot as plt\nplt.show()\n</code></pre>"},{"location":"elements/circuit/#number-of-instances","title":"Number of instances","text":"<p>With the method <code>count_intances</code> we can obtain a dictionary containing the names of all components instanciated in a circuit and their total number. This number is calculated from the dependency graph.</p> <pre><code>instances = netlist.count_instances()\n</code></pre>"},{"location":"elements/component/","title":"Component","text":"<p>A <code>component</code> is the most basic unit inside a circuit. It defines single units inside a circuit like resistors, capacitors, transistors or even custom components.</p>"},{"location":"elements/component/#creation-of-components","title":"Creation of components","text":"Creation of a simple Resistance<pre><code>class R(Component):\ndef __init__(self, ports , params = None):\ndefaults: Params = {\"R\": 1e3}\nuser_params = dict(params) if params else {}\nsuper(R, self).__init__(ports, {**defaults, **user_params}, name=\"Res\")\ndef fmt(self) -&gt; str:\ndef fmt_net(net):\nreturn f\"net{net}\" if isinstance(net, int) else net\nports = \" \".join(map(fmt_net, self.ports))\nreturn f'R{self.num_id} ({ports}) R {self.params[\"R\"]}'\n</code></pre> <p>A component may implement an additional method called <code>fmt()</code>. This method accepts no argument and should return the string representation of the component.</p>"},{"location":"elements/component/#wrapper-for-simple-components","title":"Wrapper for simple components","text":"<p>The process of creating multiple simple components can be tedious. The wrapper <code>@simple_component</code> allows to create components similarly to a dataclass.</p> <pre><code>@simple_component\nclass C(Component):\nname: \"Capacitor\"\nletter: \"C\"\ndefaults: Params = {\"C\": 1e3, \"T\": None}\n</code></pre>"},{"location":"elements/component/#component-models","title":"Component models","text":"<p>A model allows to reuse a component name and a set of parameters across multiple definitions.</p> Creation of a NMOS model<pre><code>NMOS = Model(\nname=\"nmosfet\",\nparams={\n\"w\": 0.135,\n...\n},\n)\n</code></pre> <pre><code>@simple_component\nclass NMosfet(Component):\nmodel = NMOS\nclass NMosfet(Component):\ndef __init__(self, ports, params = None, name = None):\nparameters = params if params else {}\nsuper(Mosfet, self).__init__(ports, parameters, model=NMOS, name=name)\n</code></pre> <p>To see more about generating and storing models, please see parsers and exporters</p>"},{"location":"elements/component/#serialization-and-deserialization","title":"Serialization and deserialization","text":"<p>Components can be serialized to a dict by using the <code>to_dict</code> method. To serialize to JSON, use the <code>to_json</code> method.</p> Example of serializing and deserialization<pre><code>mosfet = NMosfet([\"in\", \"out\", GND, VDD])\ndata = mosfet.to_dict()\nassert mosfet == NMosfet.from_dict(data)\njson_str = mosfet.to_json()\nassert mosfet == NMosfet.from_json(json_str)\n</code></pre>"},{"location":"elements/subcircuit/","title":"Subcircuit","text":"<p>A subcircuit is a collection of basic components or other subcircuits.</p>"},{"location":"elements/subcircuit/#creating-a-subcircuit","title":"Creating a subcircuit","text":"Example of creating an inverter<pre><code>INV = Subckt(\"INV\", [\"in\", \"out\"], {})\nINV.add(Mosfet([\"out\", \"in\", GND, GND], name=\"nmos\"))\nINV.add(Mosfet([\"out\", \"in\", VDD, VDD], name=\"pmos\"))\nINV.fix()\n</code></pre> <p>Subcircuits can be fixed with the <code>fix</code> metohd to prevent adding more components.</p>"},{"location":"elements/subcircuit/#instanciating-a-subcircuit","title":"Instanciating a subcircuit","text":"<p>A subcircuit can be instanciated by using the <code>inst</code> method. This method returns a <code>Component</code> so we can manipulate the results as with any other component.</p> <p>The same subcircuit can be instanciated multiple times with different ports or parameters.</p> Instanciating an inverter<pre><code>inv = INV.inst([\"input\", net()], {})\n</code></pre>"}]}