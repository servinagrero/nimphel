{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Installation Note The project will be available on PyPi shortly. Nimphel can be installed by running one of the following commands. $ pip install . $ poetry install","title":"Introduction"},{"location":"#installation","text":"Note The project will be available on PyPi shortly. Nimphel can be installed by running one of the following commands. $ pip install . $ poetry install","title":"Installation"},{"location":"exporters/","text":"Exporters Exporters allow the generation of a text file based on a series of elements. Their main use is to generate a SPICE netlist from a Circuit. There are however, exporters to save models to files to be loaded later on. Exporting to a netlist Any circuit can be exported to a netlist by using the export() method. This method only requires the exporter class. Exporting a circuit from nimphel.exporters import Exporter netlist . export ( Exporter ) To export directly to a file, use the method export_to_file() . Exporting a circuit to a file netlist . export_to_file ( \"/path/to/file\" , Exporter ) Custom Exporter As of today only the following exporters are implemented: SpectreExporter . A custom exporter can be created by implementing the following interface. Info When writing an exporter, it is advised to check if a component implements the fmt() method and use it instead. class Exporter : \"\"\"Interface for a Exporter.\"\"\" def fmt_component ( self , component ) -> str : \"\"\"Format a component instance.\"\"\" raise NotImplementedError def fmt_subckt ( self , subcircuit ) -> str : \"\"\"Format a subcircuit definition.\"\"\" raise NotImplementedError def fmt_net ( self , net ) -> str : \"\"\"Format a net.\"\"\" raise NotImplementedError Exporting models Models can be exported to a YAML file by using the function models_to_yaml() . These models can be read back by using the yaml parser (see parsers ). models_to_yaml ( models , \"/path/to/models.yml\" ) Info In the future, custom exporters will be added to resemble the functionality of the parsers.","title":"Exporters"},{"location":"exporters/#exporters","text":"Exporters allow the generation of a text file based on a series of elements. Their main use is to generate a SPICE netlist from a Circuit. There are however, exporters to save models to files to be loaded later on.","title":"Exporters"},{"location":"exporters/#exporting-to-a-netlist","text":"Any circuit can be exported to a netlist by using the export() method. This method only requires the exporter class. Exporting a circuit from nimphel.exporters import Exporter netlist . export ( Exporter ) To export directly to a file, use the method export_to_file() . Exporting a circuit to a file netlist . export_to_file ( \"/path/to/file\" , Exporter )","title":"Exporting to a netlist"},{"location":"exporters/#custom-exporter","text":"As of today only the following exporters are implemented: SpectreExporter . A custom exporter can be created by implementing the following interface. Info When writing an exporter, it is advised to check if a component implements the fmt() method and use it instead. class Exporter : \"\"\"Interface for a Exporter.\"\"\" def fmt_component ( self , component ) -> str : \"\"\"Format a component instance.\"\"\" raise NotImplementedError def fmt_subckt ( self , subcircuit ) -> str : \"\"\"Format a subcircuit definition.\"\"\" raise NotImplementedError def fmt_net ( self , net ) -> str : \"\"\"Format a net.\"\"\" raise NotImplementedError","title":"Custom Exporter"},{"location":"exporters/#exporting-models","text":"Models can be exported to a YAML file by using the function models_to_yaml() . These models can be read back by using the yaml parser (see parsers ). models_to_yaml ( models , \"/path/to/models.yml\" ) Info In the future, custom exporters will be added to resemble the functionality of the parsers.","title":"Exporting models"},{"location":"manipulation/","text":"Manipulation The manipulation of components is one of the key features of nimphel. Nimphel makes use of the basic mathematical operators to manipulate components. Chain Chained components start in the component input and generate a chain where the input of a new component is the output of the previous one. The operator * is used to chain components. The ports of chained components follow this behaviour: (in, out) -> (out, net()) -> ... (net(), net()) Example of chained components Res = R ([ GND , net ()]) netlist . add ( Res * 3 ) # Will produce 3 resistances with the ports: # (GND, 1), (1, 2), (2, 3) Parallel Components in parallel share the same input and output. The operator | is used to create components in parallel. The ports of components in parallel follow this behaviour: (in, out) -> (in, out) -> ... (in, out) Example of components in parallel Res = R ([ GND , net ()]) netlist . add ( Res | 3 ) # Will produce 3 resistances with the ports # (GND, 1), (GND, 1), (GND, 1) Self loop A self loop creates a copy of the component and reverses the order of the ports, that is, input is connected to output and viceversa. The operator ~ is used to create self loops. The ports of components in self loop this behaviour: (in, out) -> (out, in) Example of self looped components Res = R ([ GND , net ()]) netlist . add ( ~ Res ) # Will produce 2 resistances with the ports # (GND, 1), (1, GND) Fan out Components in fan out share the same input but have a different output port each. The operator ^ is used to create fan outs. The ports of components in fan out follow this behaviour: (in, out) -> (in, net()) -> ... (in, net()) Example of components in fan out Res = R ([ GND , net ()]) netlist . add ( Res ^ 3 ) # Will produce 3 resistances with the ports # (GND, 1), (GND, 2), (GND, 3) Direct Components that are directed, have the same output but have a different input each. It's behaviour is the opposite of fan out . The operator & is used to create self loops. The ports of components in fan out follow this behaviour: (in, out) -> (net(), out) -> ... (net(), out) Example of directed components. Res = R ([ GND , net ()]) netlist . add ( Res & 3 ) # Will produce 3 resistances with the ports # (2, 1), (3, 1), (4, 1) Complex manipulation For components that are more complex, there are methods to defined the connections. The ports for chains are defined using masks, that is, a tuple whose non null positions mark the number of ports to chain. A chain will not work in this case with a Mosfet since the chain will be done, with the ports \"out\" and \"GND\". We need to define the chain using the first and second port. m = Mosfet ([ \"out\" , \"in\" , GND , GND ], name = \"nmos\" ) m . chain (( 1 , 1 , 0 , 0 ), 3 ) m . parallel (( 1 , 1 , 0 , 0 ), 3 ) m . self_loop (( 1 , 1 , 0 , 0 ), 3 ) m . fanout (( 1 , 1 , 0 , 0 ), 3 ) m . direct (( 1 , 1 , 0 , 0 ), 3 ) Getting ports Setting ports 1D and 2D Arrays Components that follow a 1D or 2D configuration can be instanciated quickly by usig the function make_array . This function takes 3 arguments. Tuple containing the 1D or 2D dimensions of the array. The coordinates are given as (Y, X) The component instance that will be used to fill the array. If provided, a function that will received the coordinates of the component and will return the ports of that component. Generating a 1D array of resistances def ports_res ( p ): return [ f 'X_ { c [ 0 ] } ' , GND ] arr = make_array (( 5 , ), R ([ \"\" , \"\" ]), ports_fn = ports_res ) netlist . add ( arr ) Generating a 2D array of resistances def ports_res ( p ): x , y = p return [ f \"Y_ { y } \" , f \"X_ { x } \" ] arr = make_array (( 3 , 5 ), R ([ \"\" , \"\" ]), ports_fn = ports_res ) netlist . add ( arr ) The array is created by using numpy, so we have access to numpy tools. Printing an array of components. for y , x in np . ndindex ( m . shape ): print ( arr [ y , x ])","title":"Manipulation"},{"location":"manipulation/#manipulation","text":"The manipulation of components is one of the key features of nimphel. Nimphel makes use of the basic mathematical operators to manipulate components.","title":"Manipulation"},{"location":"manipulation/#chain","text":"Chained components start in the component input and generate a chain where the input of a new component is the output of the previous one. The operator * is used to chain components. The ports of chained components follow this behaviour: (in, out) -> (out, net()) -> ... (net(), net()) Example of chained components Res = R ([ GND , net ()]) netlist . add ( Res * 3 ) # Will produce 3 resistances with the ports: # (GND, 1), (1, 2), (2, 3)","title":"Chain"},{"location":"manipulation/#parallel","text":"Components in parallel share the same input and output. The operator | is used to create components in parallel. The ports of components in parallel follow this behaviour: (in, out) -> (in, out) -> ... (in, out) Example of components in parallel Res = R ([ GND , net ()]) netlist . add ( Res | 3 ) # Will produce 3 resistances with the ports # (GND, 1), (GND, 1), (GND, 1)","title":"Parallel"},{"location":"manipulation/#self-loop","text":"A self loop creates a copy of the component and reverses the order of the ports, that is, input is connected to output and viceversa. The operator ~ is used to create self loops. The ports of components in self loop this behaviour: (in, out) -> (out, in) Example of self looped components Res = R ([ GND , net ()]) netlist . add ( ~ Res ) # Will produce 2 resistances with the ports # (GND, 1), (1, GND)","title":"Self loop"},{"location":"manipulation/#fan-out","text":"Components in fan out share the same input but have a different output port each. The operator ^ is used to create fan outs. The ports of components in fan out follow this behaviour: (in, out) -> (in, net()) -> ... (in, net()) Example of components in fan out Res = R ([ GND , net ()]) netlist . add ( Res ^ 3 ) # Will produce 3 resistances with the ports # (GND, 1), (GND, 2), (GND, 3)","title":"Fan out"},{"location":"manipulation/#direct","text":"Components that are directed, have the same output but have a different input each. It's behaviour is the opposite of fan out . The operator & is used to create self loops. The ports of components in fan out follow this behaviour: (in, out) -> (net(), out) -> ... (net(), out) Example of directed components. Res = R ([ GND , net ()]) netlist . add ( Res & 3 ) # Will produce 3 resistances with the ports # (2, 1), (3, 1), (4, 1)","title":"Direct"},{"location":"manipulation/#complex-manipulation","text":"For components that are more complex, there are methods to defined the connections. The ports for chains are defined using masks, that is, a tuple whose non null positions mark the number of ports to chain. A chain will not work in this case with a Mosfet since the chain will be done, with the ports \"out\" and \"GND\". We need to define the chain using the first and second port. m = Mosfet ([ \"out\" , \"in\" , GND , GND ], name = \"nmos\" ) m . chain (( 1 , 1 , 0 , 0 ), 3 ) m . parallel (( 1 , 1 , 0 , 0 ), 3 ) m . self_loop (( 1 , 1 , 0 , 0 ), 3 ) m . fanout (( 1 , 1 , 0 , 0 ), 3 ) m . direct (( 1 , 1 , 0 , 0 ), 3 )","title":"Complex manipulation"},{"location":"manipulation/#getting-ports","text":"","title":"Getting ports"},{"location":"manipulation/#setting-ports","text":"","title":"Setting ports"},{"location":"manipulation/#1d-and-2d-arrays","text":"Components that follow a 1D or 2D configuration can be instanciated quickly by usig the function make_array . This function takes 3 arguments. Tuple containing the 1D or 2D dimensions of the array. The coordinates are given as (Y, X) The component instance that will be used to fill the array. If provided, a function that will received the coordinates of the component and will return the ports of that component. Generating a 1D array of resistances def ports_res ( p ): return [ f 'X_ { c [ 0 ] } ' , GND ] arr = make_array (( 5 , ), R ([ \"\" , \"\" ]), ports_fn = ports_res ) netlist . add ( arr ) Generating a 2D array of resistances def ports_res ( p ): x , y = p return [ f \"Y_ { y } \" , f \"X_ { x } \" ] arr = make_array (( 3 , 5 ), R ([ \"\" , \"\" ]), ports_fn = ports_res ) netlist . add ( arr ) The array is created by using numpy, so we have access to numpy tools. Printing an array of components. for y , x in np . ndindex ( m . shape ): print ( arr [ y , x ])","title":"1D and 2D Arrays"},{"location":"parsers/","text":"Parsers Parsers allow the generation of models automatically from files. Nimphel comes with some parsers by default. If some technology file is not supported file it's very easy to create your custom parser. Parsing a definition file requires two things. The function parse_model_file() The parser that will be used for the file. The parser has the signature def parser ( lib : TextIO ) -> Dict [ str , Model ] Loading models from a YAML file models = parse_model_file ( \"/path/to/models.yaml\" , yaml_parser ) @simple_component class NMosfet ( Component ): model = models [ 'NMOS' ] As of today the following parsers are implemented: eldo_parser() , veriloga_parser() , yaml_parser() . Info More parsers may be added in the future. The current parsers can be used as a refernce to create a custom parser. Models in YAML The yaml_parser() allows reading models from a YAML file. Each document inside the file represents a single model. A different YAML file can be created for a different technology, so that the same netlist can be created with the same code for different technologies just by changing the file. Example of a YAML configuration name : NMOS params : w : 0.135 nfing : 1 mult : 1 srcefirst : 1 ngcon : 1 mismatch : 1 lpe : 0 dnoise_mdev : 0 dmu_mdev : 0 dvt_mdev : 0 numcos : 1 numcod : 1 --- # Used to separate models name : PMOS params : from : NMOS # Use the parameters of NMOS w : 0.27 # Parameters can be updated new_val : 42 # New parameters can be added mismatch : ~ # Values can also be deleted The second document inside the YAML file shows the functionalities added to the file. Params can be copied from another defined model by using the key from . Parameters can be added, updated or even removed when referencing another model.","title":"Parsers"},{"location":"parsers/#parsers","text":"Parsers allow the generation of models automatically from files. Nimphel comes with some parsers by default. If some technology file is not supported file it's very easy to create your custom parser. Parsing a definition file requires two things. The function parse_model_file() The parser that will be used for the file. The parser has the signature def parser ( lib : TextIO ) -> Dict [ str , Model ] Loading models from a YAML file models = parse_model_file ( \"/path/to/models.yaml\" , yaml_parser ) @simple_component class NMosfet ( Component ): model = models [ 'NMOS' ] As of today the following parsers are implemented: eldo_parser() , veriloga_parser() , yaml_parser() . Info More parsers may be added in the future. The current parsers can be used as a refernce to create a custom parser.","title":"Parsers"},{"location":"parsers/#models-in-yaml","text":"The yaml_parser() allows reading models from a YAML file. Each document inside the file represents a single model. A different YAML file can be created for a different technology, so that the same netlist can be created with the same code for different technologies just by changing the file. Example of a YAML configuration name : NMOS params : w : 0.135 nfing : 1 mult : 1 srcefirst : 1 ngcon : 1 mismatch : 1 lpe : 0 dnoise_mdev : 0 dmu_mdev : 0 dvt_mdev : 0 numcos : 1 numcod : 1 --- # Used to separate models name : PMOS params : from : NMOS # Use the parameters of NMOS w : 0.27 # Parameters can be updated new_val : 42 # New parameters can be added mismatch : ~ # Values can also be deleted The second document inside the YAML file shows the functionalities added to the file. Params can be copied from another defined model by using the key from . Parameters can be added, updated or even removed when referencing another model.","title":"Models in YAML"},{"location":"elements/circuit/","text":"Creating a subcircuit Example of creating an AND gate and_gate = Circuit () out_and = net () and_gate . add ( Mosfet ([ \"A\" , VDD , \"OUT\" , VDD ], name = \"pmos\" )) and_gate . add ( Mosfet ([ \"B\" , VDD , \"OUT\" , VDD ], name = \"pmos\" )) and_gate . add ( Mosfet ([ \"B\" , \"OUT\" , out_and , GND ], name = \"nmos\" )) and_gate . add ( Mosfet ([ \"A\" , out_and , GND , GND ], name = \"nmos\" )) AND_GATE = and_gate . into_subckt ( \"AND\" , [ \"A\" , \"B\" , \"OUT\" ], {}) Global circuit There is a global circuit called netlist that exists within nimphel. Dependency graph graph = netlist . to_graph () generate_graph ( graph ) Number of instances netlist . coutn_instances ()","title":"Circuits"},{"location":"elements/circuit/#creating-a-subcircuit","text":"Example of creating an AND gate and_gate = Circuit () out_and = net () and_gate . add ( Mosfet ([ \"A\" , VDD , \"OUT\" , VDD ], name = \"pmos\" )) and_gate . add ( Mosfet ([ \"B\" , VDD , \"OUT\" , VDD ], name = \"pmos\" )) and_gate . add ( Mosfet ([ \"B\" , \"OUT\" , out_and , GND ], name = \"nmos\" )) and_gate . add ( Mosfet ([ \"A\" , out_and , GND , GND ], name = \"nmos\" )) AND_GATE = and_gate . into_subckt ( \"AND\" , [ \"A\" , \"B\" , \"OUT\" ], {})","title":"Creating a subcircuit"},{"location":"elements/circuit/#global-circuit","text":"There is a global circuit called netlist that exists within nimphel.","title":"Global circuit"},{"location":"elements/circuit/#dependency-graph","text":"graph = netlist . to_graph () generate_graph ( graph )","title":"Dependency graph"},{"location":"elements/circuit/#number-of-instances","text":"netlist . coutn_instances ()","title":"Number of instances"},{"location":"elements/component/","text":"Creation of components Creation of a simple Resistance class R ( Component ): def __init__ ( self , ports , params = None ): defaults : Params = { \"R\" : 1e3 } user_params = dict ( params ) if params else {} super ( R , self ) . __init__ ( ports , { ** defaults , ** user_params }, name = \"Res\" ) def fmt ( self ) -> str : def fmt_net ( net ): return f \"net { net } \" if isinstance ( net , int ) else net ports = \" \" . join ( map ( fmt_net , self . ports )) return f 'R { self . num_id } ( { ports } ) R { self . params [ \"R\" ] } ' A component may implement an additional method called fmt() . This method accepts no argument and should return the string representation of the component. Wrapper for simple components The process of creating multiple simple components can be tedious. The wrapper @simple_component allows to create components similarly to a dataclass. @simple_component class C ( Component ): name : \"Capacitor\" letter : \"C\" defaults : Params = { \"C\" : 1e3 , \"T\" : None } Component models A model allows to reuse a component name and a set of parameters across multiple definitions. Creation of a NMOS model NMOS = Model ( name = \"nmosfet\" , params = { \"w\" : 0.135 , ... }, ) @simple_component class NMosfet ( Component ): model = NMOS class NMosfet ( Component ): def __init__ ( self , ports , params = None , name = None ): parameters = params if params else {} super ( Mosfet , self ) . __init__ ( ports , parameters , model = NMOS , name = name ) To see more about generating and storing models, please see parsers and exporters Serialization and deserialization Components can be serialized to a dict by using the to_dict() method. To serialize to JSON, use the to_json() method. Example of serializing and deserialization mosfet = NMosfet ([ \"in\" , \"out\" , GND , VDD ]) data = mosfet . to_dict () assert mosfet == NMosfet . from_dict ( data ) json_str = mosfet . to_json () assert mosfet == NMosfet . from_json ( json_str )","title":"Components"},{"location":"elements/component/#creation-of-components","text":"Creation of a simple Resistance class R ( Component ): def __init__ ( self , ports , params = None ): defaults : Params = { \"R\" : 1e3 } user_params = dict ( params ) if params else {} super ( R , self ) . __init__ ( ports , { ** defaults , ** user_params }, name = \"Res\" ) def fmt ( self ) -> str : def fmt_net ( net ): return f \"net { net } \" if isinstance ( net , int ) else net ports = \" \" . join ( map ( fmt_net , self . ports )) return f 'R { self . num_id } ( { ports } ) R { self . params [ \"R\" ] } ' A component may implement an additional method called fmt() . This method accepts no argument and should return the string representation of the component.","title":"Creation of components"},{"location":"elements/component/#wrapper-for-simple-components","text":"The process of creating multiple simple components can be tedious. The wrapper @simple_component allows to create components similarly to a dataclass. @simple_component class C ( Component ): name : \"Capacitor\" letter : \"C\" defaults : Params = { \"C\" : 1e3 , \"T\" : None }","title":"Wrapper for simple components"},{"location":"elements/component/#component-models","text":"A model allows to reuse a component name and a set of parameters across multiple definitions. Creation of a NMOS model NMOS = Model ( name = \"nmosfet\" , params = { \"w\" : 0.135 , ... }, ) @simple_component class NMosfet ( Component ): model = NMOS class NMosfet ( Component ): def __init__ ( self , ports , params = None , name = None ): parameters = params if params else {} super ( Mosfet , self ) . __init__ ( ports , parameters , model = NMOS , name = name ) To see more about generating and storing models, please see parsers and exporters","title":"Component models"},{"location":"elements/component/#serialization-and-deserialization","text":"Components can be serialized to a dict by using the to_dict() method. To serialize to JSON, use the to_json() method. Example of serializing and deserialization mosfet = NMosfet ([ \"in\" , \"out\" , GND , VDD ]) data = mosfet . to_dict () assert mosfet == NMosfet . from_dict ( data ) json_str = mosfet . to_json () assert mosfet == NMosfet . from_json ( json_str )","title":"Serialization and deserialization"},{"location":"elements/subcircuit/","text":"Creating a subcircuit Example of creating an inverter INV = Subckt ( \"INV\" , [ \"in\" , \"out\" ], {}) INV . add ( Mosfet ([ \"out\" , \"in\" , GND , GND ], name = \"nmos\" )) INV . add ( Mosfet ([ \"out\" , \"in\" , VDD , VDD ], name = \"pmos\" )) INV . fix () # Prevents the subcircuit of adding more components Instanciating a subcircuit A subcircuit can be instanciated by usig the 'inst()' method. This method takes the same arguments as Component . Instanciating an inverter inv = INV . inst ([ \"input\" , net ()], {})","title":"Subcircuits"},{"location":"elements/subcircuit/#creating-a-subcircuit","text":"Example of creating an inverter INV = Subckt ( \"INV\" , [ \"in\" , \"out\" ], {}) INV . add ( Mosfet ([ \"out\" , \"in\" , GND , GND ], name = \"nmos\" )) INV . add ( Mosfet ([ \"out\" , \"in\" , VDD , VDD ], name = \"pmos\" )) INV . fix () # Prevents the subcircuit of adding more components","title":"Creating a subcircuit"},{"location":"elements/subcircuit/#instanciating-a-subcircuit","text":"A subcircuit can be instanciated by usig the 'inst()' method. This method takes the same arguments as Component . Instanciating an inverter inv = INV . inst ([ \"input\" , net ()], {})","title":"Instanciating a subcircuit"}]}