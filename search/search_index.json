{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Installation Note The project will be available on PyPi shortly. Nimphel can be installed by running one of the following commands. $ pip install . $ poetry install","title":"Introduction"},{"location":"#installation","text":"Note The project will be available on PyPi shortly. Nimphel can be installed by running one of the following commands. $ pip install . $ poetry install","title":"Installation"},{"location":"api/","text":"Component Class to save component instances. There can be no two instances of the same component with the same id, except if one of them is inside a subcircuit. The name of the device is the first not null name in the list of names. The list of names han the following priority User defined name. Model name. Name of the subclass. Attributes: Name Type Description num_id Numeric id given to the instance. name str Name of the component instance. ports List of ports of the component. params Dict of parameters using the model parameters as default if provided. Raises: Type Description AttributeError The list of ports is empty Source code in nimphel/component.py 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 class Component : \"\"\"Class to save component instances. There can be no two instances of the same component with the same id, except if one of them is inside a subcircuit. The name of the device is the first not null name in the list of names. The list of names han the following priority: 1. User defined name. 2. Model name. 3. Name of the subclass. Attributes: num_id: Numeric id given to the instance. name: Name of the component instance. ports: List of ports of the component. params: Dict of parameters using the model parameters as default if provided. Raises: AttributeError: The list of ports is empty \"\"\" def __init__ ( self , ports : Ports , params : Optional [ Params ] = None , name : Optional [ str ] = None , letter : Optional [ str ] = None , model : Optional [ Model ] = None , ): self . _name = [ name , model . name if model else None , type ( self ) . __name__ ] self . letter = letter if letter else self . name [ 0 ] . upper () if not ports : raise ValueError ( f \"Ports for { self . name } cannot empty.\" ) self . ports = ports self . num_id = nimphel . netlist . instances [ self . name ] nimphel . netlist . instances [ self . name ] += 1 self . model = model user_params = params if params else {} if model : self . params = { ** model . params , ** user_params } else : self . params = user_params @property def name ( self ) -> str : \"\"\"Returns the name of the component. Returns: The actual name of the device. \"\"\" return next ( filter ( bool , self . _name ), \"\" ) @name . setter def name ( self , name : str ): \"\"\"The name is set as a user defined name.\"\"\" self . _name [ 0 ] = name @classmethod def from_dict ( cls , data : Dict [ str , Any ]) -> Component : \"\"\"Create a component from a Dictionaly.\"\"\" model = data . get ( \"model\" , None ) if model : model = Model ( ** model ) return cls ( data [ \"ports\" ], params = data . get ( \"params\" , {}), name = data . get ( \"name\" , None ), letter = data . get ( \"letter\" , None ), model = model , ) @classmethod def from_json ( cls , json_str : str ) -> Component : \"\"\"Create a component from a JSON string.\"\"\" data = json . loads ( json_str ) model = data . get ( \"model\" , None ) if model : model = Model ( ** model ) return cls ( data [ \"ports\" ], params = data . get ( \"params\" , {}), name = data . get ( \"name\" , None ), letter = data . get ( \"letter\" , None ), model = model , ) def to_json ( self ) -> str : \"\"\"Returns the string representation of the component.\"\"\" return json . dumps ( self . to_dict ()) def __pos__ ( self ) -> Component : \"\"\"Make a copy and increment the id of the new component. The component is copied using deepcopy. Returns: The new component with num_id increased by 1. \"\"\" other = copy . deepcopy ( self ) other . num_id += 1 nimphel . netlist . instances [ self . name ] += 1 return other def loop ( self , mask : Optional [ Tuple [ int , ... ]] = None ) -> Tuple [ Component , Component ]: \"\"\"Create a self loop of a component given a mask. Example: Given a component with ports [IN, VDD, OUT, GND] and mask (1, 0, 1, 0), loop will return a list of components with ports [IN, VDD, OUT, GND] and [OUT, VDD, IN, GND] Args: mask: Mask to select the two ports to loop. If None, use the first two ports. Returns: Tuple containing both elements of the loop. Raises: ValueError: The mask has more or less than two ports selected. \"\"\" if len ( self . ports ) < 2 : raise ValueError ( \"Component cannot self loop as it only has one port.\" ) if mask is None : mask = ( 1 , 1 ) + ( 0 ,) * max ( len ( self . ports ), 0 ) elif sum ( mask ) != 2 : raise ValueError ( \"Two ports are needed to create a self loop.\" ) other = + self first = mask . index ( 1 ) second = mask . index ( 1 , first + 1 ) other . ports [ first ], other . ports [ second ] = ( other . ports [ second ], other . ports [ first ], ) return ( self , other ) def __invert__ ( self ) -> Tuple [ Component , Component ]: \"\"\"Create a self loop of a component. Overloaded operator for ``loop``\"\"\" return self . loop () def __lshift__ ( self , val : int ): \"\"\"Shift the ports in the left direction.\"\"\" self . ports = self . ports [: val ] + self . ports [ val :] def __rshift__ ( self , val : int ): \"\"\"Shift the ports in the right direction.\"\"\" self . __lshift__ ( - val ) def chain ( self , val : Union [ int , Tuple [ Net , ... ], Tuple [ int , Callable [[ int ], str ]]], mask : Optional [ Mask ] = None , ) -> List [ Component ]: \"\"\"If val is a tuple, various things can happen. First, len(tuple) == len(comp.ports) If the value is 0, that port is fixed and does not change. If the value is 1, that port is used for chaining, from left to right. comp * (0, 0, 1, 1) Following the left to right rule, if the values are strings, they will be used for the first and last name of the nets. comp * (0, 0, \"first\", \"out\") The user can also supply a function instead of a str or int. The function will be given the index of the chain and should return a net. comp * (0, 0, \"Input\", lambda d: f'net{d}') If val is an int, chain `val` times as normal, that is (in, out) -> (out, net()) -> ... -> (net(), net()) Only the global state keeps track of the updated ids, this means that the original component mantains it's id. Args: val: mask: Returns: List containing the chain of components. TODO: * Use the mask to select the ports \"\"\" components = [ self ] if isinstance ( val , tuple ): nelem = val [ 0 ] if isinstance ( val [ 1 ], Callable ): last_name = val [ 1 ] else : last_name = lambda : val [ 1 ] else : nelem = val last_name = net _ , * unchanged , last_port = self . ports new_out = net () for i in range ( 1 , nelem ): new_ports = [ last_port , * unchanged , new_out ] new_comp = + components [ - 1 ] new_comp . ports = new_ports components . append ( new_comp ) if i != ( nelem - 2 ): last_port , new_out = new_out , net () else : last_port , new_out = new_out , last_name () return components def __mul__ ( self , val : Union [ int , Tuple [ Net , ... ], Tuple [ int , Callable [[ int ], str ]]] ) -> List [ Component ]: \"\"\"Create components in a chain. Overloaded operator for ``chan``. \"\"\" return self . chain ( val ) def parallel ( self , val : int ) -> List [ Component ]: \"\"\"Create components in parallel. Components in parallel share the same input and output ports. Args: val: Number of components to create. Returns: List containing the components in parallel. \"\"\" components = [ self ] for _ in range ( 1 , val ): new_comp = + components [ - 1 ] components . append ( new_comp ) return components def __or__ ( self , val : int ) -> List [ Component ]: \"\"\"Create components in parallel. Overloaded operator for ``parallel``\"\"\" return self . parallel ( val ) def fanout ( self , val : int ) -> List [ Component ]: \"\"\"Create components with the same input and different output. Args: val: Number of components to create. Returns: List of components. \"\"\" self . ports [ - 1 ] = net () components = [ self ] for _ in range ( 1 , val ): new_comp = + components [ - 1 ] new_comp . ports [ - 1 ] = net () components . append ( new_comp ) return components def __xor__ ( self , val : int ) -> List [ Component ]: \"\"\"Create components with the same input and different output. Overloaded operator for ``fanout``.\"\"\" return self . fanout ( val ) def direct ( self , val : int ) -> List [ Component ]: \"\"\"Create components with the different inputs and same output. The first port of the component used to call the method gets modified. Args: val: Number of components to create. Returns: List of components. \"\"\" components = [ self ] for _ in range ( 1 , val ): new_comp = + components [ - 1 ] new_comp . ports [ 0 ] = net () components . append ( new_comp ) return components def __and__ ( self , val : int ) -> List [ Component ]: \"\"\"Create components with the different inputs and same output. Overloaded operator for ``direct``.\"\"\" return self . direct ( val ) def to_dict ( self ) -> Dict [ str , Any ]: \"\"\"Export a component to a dict\"\"\" model = None if not self . model else asdict ( self . model ) return { \"letter\" : self . letter , \"name\" : self . name , \"id\" : self . num_id , \"ports\" : self . ports , \"model\" : model , \"params\" : self . params , } __and__ ( val ) Create components with the different inputs and same output. Overloaded operator for direct . Source code in nimphel/component.py 341 342 343 344 def __and__ ( self , val : int ) -> List [ Component ]: \"\"\"Create components with the different inputs and same output. Overloaded operator for ``direct``.\"\"\" return self . direct ( val ) __invert__ () Create a self loop of a component. Overloaded operator for loop Source code in nimphel/component.py 194 195 196 197 def __invert__ ( self ) -> Tuple [ Component , Component ]: \"\"\"Create a self loop of a component. Overloaded operator for ``loop``\"\"\" return self . loop () __lshift__ ( val ) Shift the ports in the left direction. Source code in nimphel/component.py 199 200 201 def __lshift__ ( self , val : int ): \"\"\"Shift the ports in the left direction.\"\"\" self . ports = self . ports [: val ] + self . ports [ val :] __mul__ ( val ) Create components in a chain. Overloaded operator for chan . Source code in nimphel/component.py 269 270 271 272 273 274 275 def __mul__ ( self , val : Union [ int , Tuple [ Net , ... ], Tuple [ int , Callable [[ int ], str ]]] ) -> List [ Component ]: \"\"\"Create components in a chain. Overloaded operator for ``chan``. \"\"\" return self . chain ( val ) __or__ ( val ) Create components in parallel. Overloaded operator for parallel Source code in nimphel/component.py 295 296 297 298 def __or__ ( self , val : int ) -> List [ Component ]: \"\"\"Create components in parallel. Overloaded operator for ``parallel``\"\"\" return self . parallel ( val ) __pos__ () Make a copy and increment the id of the new component. The component is copied using deepcopy. Returns: Type Description Component The new component with num_id increased by 1. Source code in nimphel/component.py 147 148 149 150 151 152 153 154 155 156 157 158 def __pos__ ( self ) -> Component : \"\"\"Make a copy and increment the id of the new component. The component is copied using deepcopy. Returns: The new component with num_id increased by 1. \"\"\" other = copy . deepcopy ( self ) other . num_id += 1 nimphel . netlist . instances [ self . name ] += 1 return other __rshift__ ( val ) Shift the ports in the right direction. Source code in nimphel/component.py 203 204 205 def __rshift__ ( self , val : int ): \"\"\"Shift the ports in the right direction.\"\"\" self . __lshift__ ( - val ) __xor__ ( val ) Create components with the same input and different output. Overloaded operator for fanout . Source code in nimphel/component.py 317 318 319 320 def __xor__ ( self , val : int ) -> List [ Component ]: \"\"\"Create components with the same input and different output. Overloaded operator for ``fanout``.\"\"\" return self . fanout ( val ) chain ( val , mask = None ) If val is a tuple, various things can happen. First, len(tuple) == len(comp.ports) If the value is 0, that port is fixed and does not change. If the value is 1, that port is used for chaining, from left to right. comp * (0, 0, 1, 1) Following the left to right rule, if the values are strings, they will be used for the first and last name of the nets. comp * (0, 0, \"first\", \"out\") The user can also supply a function instead of a str or int. The function will be given the index of the chain and should return a net. comp * (0, 0, \"Input\", lambda d: f'net{d}') If val is an int, chain val times as normal, that is (in, out) -> (out, net()) -> ... -> (net(), net()) Only the global state keeps track of the updated ids, this means that the original component mantains it's id. Parameters: Name Type Description Default val Union [ int , Tuple [ Net , ...], Tuple [ int , Callable [[ int ], str ]]] required mask Optional [ Mask ] None Returns: Type Description List [ Component ] List containing the chain of components. TODO Use the mask to select the ports Source code in nimphel/component.py 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 def chain ( self , val : Union [ int , Tuple [ Net , ... ], Tuple [ int , Callable [[ int ], str ]]], mask : Optional [ Mask ] = None , ) -> List [ Component ]: \"\"\"If val is a tuple, various things can happen. First, len(tuple) == len(comp.ports) If the value is 0, that port is fixed and does not change. If the value is 1, that port is used for chaining, from left to right. comp * (0, 0, 1, 1) Following the left to right rule, if the values are strings, they will be used for the first and last name of the nets. comp * (0, 0, \"first\", \"out\") The user can also supply a function instead of a str or int. The function will be given the index of the chain and should return a net. comp * (0, 0, \"Input\", lambda d: f'net{d}') If val is an int, chain `val` times as normal, that is (in, out) -> (out, net()) -> ... -> (net(), net()) Only the global state keeps track of the updated ids, this means that the original component mantains it's id. Args: val: mask: Returns: List containing the chain of components. TODO: * Use the mask to select the ports \"\"\" components = [ self ] if isinstance ( val , tuple ): nelem = val [ 0 ] if isinstance ( val [ 1 ], Callable ): last_name = val [ 1 ] else : last_name = lambda : val [ 1 ] else : nelem = val last_name = net _ , * unchanged , last_port = self . ports new_out = net () for i in range ( 1 , nelem ): new_ports = [ last_port , * unchanged , new_out ] new_comp = + components [ - 1 ] new_comp . ports = new_ports components . append ( new_comp ) if i != ( nelem - 2 ): last_port , new_out = new_out , net () else : last_port , new_out = new_out , last_name () return components direct ( val ) Create components with the different inputs and same output. The first port of the component used to call the method gets modified. Parameters: Name Type Description Default val int Number of components to create. required Returns: Type Description List [ Component ] List of components. Source code in nimphel/component.py 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 def direct ( self , val : int ) -> List [ Component ]: \"\"\"Create components with the different inputs and same output. The first port of the component used to call the method gets modified. Args: val: Number of components to create. Returns: List of components. \"\"\" components = [ self ] for _ in range ( 1 , val ): new_comp = + components [ - 1 ] new_comp . ports [ 0 ] = net () components . append ( new_comp ) return components fanout ( val ) Create components with the same input and different output. Parameters: Name Type Description Default val int Number of components to create. required Returns: Type Description List [ Component ] List of components. Source code in nimphel/component.py 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 def fanout ( self , val : int ) -> List [ Component ]: \"\"\"Create components with the same input and different output. Args: val: Number of components to create. Returns: List of components. \"\"\" self . ports [ - 1 ] = net () components = [ self ] for _ in range ( 1 , val ): new_comp = + components [ - 1 ] new_comp . ports [ - 1 ] = net () components . append ( new_comp ) return components from_dict ( data ) classmethod Create a component from a Dictionaly. Source code in nimphel/component.py 114 115 116 117 118 119 120 121 122 123 124 125 126 @classmethod def from_dict ( cls , data : Dict [ str , Any ]) -> Component : \"\"\"Create a component from a Dictionaly.\"\"\" model = data . get ( \"model\" , None ) if model : model = Model ( ** model ) return cls ( data [ \"ports\" ], params = data . get ( \"params\" , {}), name = data . get ( \"name\" , None ), letter = data . get ( \"letter\" , None ), model = model , ) from_json ( json_str ) classmethod Create a component from a JSON string. Source code in nimphel/component.py 128 129 130 131 132 133 134 135 136 137 138 139 140 141 @classmethod def from_json ( cls , json_str : str ) -> Component : \"\"\"Create a component from a JSON string.\"\"\" data = json . loads ( json_str ) model = data . get ( \"model\" , None ) if model : model = Model ( ** model ) return cls ( data [ \"ports\" ], params = data . get ( \"params\" , {}), name = data . get ( \"name\" , None ), letter = data . get ( \"letter\" , None ), model = model , ) loop ( mask = None ) Create a self loop of a component given a mask. Example Given a component with ports [IN, VDD, OUT, GND] and mask (1, 0, 1, 0), loop will return a list of components with ports [IN, VDD, OUT, GND] and [OUT, VDD, IN, GND] Parameters: Name Type Description Default mask Optional [ Tuple [ int , ...]] Mask to select the two ports to loop. If None, use the first two ports. None Returns: Type Description Tuple [ Component , Component ] Tuple containing both elements of the loop. Raises: Type Description ValueError The mask has more or less than two ports selected. Source code in nimphel/component.py 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 def loop ( self , mask : Optional [ Tuple [ int , ... ]] = None ) -> Tuple [ Component , Component ]: \"\"\"Create a self loop of a component given a mask. Example: Given a component with ports [IN, VDD, OUT, GND] and mask (1, 0, 1, 0), loop will return a list of components with ports [IN, VDD, OUT, GND] and [OUT, VDD, IN, GND] Args: mask: Mask to select the two ports to loop. If None, use the first two ports. Returns: Tuple containing both elements of the loop. Raises: ValueError: The mask has more or less than two ports selected. \"\"\" if len ( self . ports ) < 2 : raise ValueError ( \"Component cannot self loop as it only has one port.\" ) if mask is None : mask = ( 1 , 1 ) + ( 0 ,) * max ( len ( self . ports ), 0 ) elif sum ( mask ) != 2 : raise ValueError ( \"Two ports are needed to create a self loop.\" ) other = + self first = mask . index ( 1 ) second = mask . index ( 1 , first + 1 ) other . ports [ first ], other . ports [ second ] = ( other . ports [ second ], other . ports [ first ], ) return ( self , other ) name () property writable Returns the name of the component. Returns: Type Description str The actual name of the device. Source code in nimphel/component.py 100 101 102 103 104 105 106 107 @property def name ( self ) -> str : \"\"\"Returns the name of the component. Returns: The actual name of the device. \"\"\" return next ( filter ( bool , self . _name ), \"\" ) parallel ( val ) Create components in parallel. Components in parallel share the same input and output ports. Parameters: Name Type Description Default val int Number of components to create. required Returns: Type Description List [ Component ] List containing the components in parallel. Source code in nimphel/component.py 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 def parallel ( self , val : int ) -> List [ Component ]: \"\"\"Create components in parallel. Components in parallel share the same input and output ports. Args: val: Number of components to create. Returns: List containing the components in parallel. \"\"\" components = [ self ] for _ in range ( 1 , val ): new_comp = + components [ - 1 ] components . append ( new_comp ) return components to_dict () Export a component to a dict Source code in nimphel/component.py 346 347 348 349 350 351 352 353 354 355 356 def to_dict ( self ) -> Dict [ str , Any ]: \"\"\"Export a component to a dict\"\"\" model = None if not self . model else asdict ( self . model ) return { \"letter\" : self . letter , \"name\" : self . name , \"id\" : self . num_id , \"ports\" : self . ports , \"model\" : model , \"params\" : self . params , } to_json () Returns the string representation of the component. Source code in nimphel/component.py 143 144 145 def to_json ( self ) -> str : \"\"\"Returns the string representation of the component.\"\"\" return json . dumps ( self . to_dict ()) Model dataclass A model holds default parameters for a specific type of component. Source code in nimphel/component.py 32 33 34 35 36 37 @dataclass class Model : \"\"\"A model holds default parameters for a specific type of component.\"\"\" name : str params : Dict [ str , ParamValue ] net () Generate a new global net. The number of nets is increased in the global circuit. Returns: Type Description int The new net. Source code in nimphel/component.py 40 41 42 43 44 45 46 47 48 49 def net () -> int : \"\"\"Generate a new global net. The number of nets is increased in the global circuit. Returns: The new net. \"\"\" nimphel . netlist . nets += 1 return int ( nimphel . netlist . nets - 1 ) simple_component ( cls ) Wrapper to create components that are very simple. Parameters: Name Type Description Default cls The class definition required Returns: Type Description The class to generate the specified component. Todo Add safety guards for the number of ports. Source code in nimphel/component.py 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 def simple_component ( cls ): \"\"\"Wrapper to create components that are very simple. Args: cls: The class definition Returns: The class to generate the specified component. Todo: * Add safety guards for the number of ports. \"\"\" cls_name = cls . __dict__ . get ( \"name\" , cls . __name__ ) cls_letter = cls . __dict__ . get ( \"letter\" , None ) cls_model = cls . __dict__ . get ( \"model\" , None ) def_params = cls . __dict__ . get ( \"defaults\" , {}) def init ( self , ports , params = None , model = None , name = None , letter = None ): user_params = {} if params is None else params super ( cls , self ) . __init__ ( ports , params = { ** def_params , ** user_params }, name = name or cls_name , letter = letter or cls_letter , model = model or cls_model , ) setattr ( cls , \"__init__\" , init ) return cls Subckt Class to handle a subcircuit. Attributes: Name Type Description name str Name of the subcircuit. components List [ Component ] List of component instances inside the subcircuit. ports Ports List of ports of the subcircuit. params Optional [ Params ] List of parameters of the subcircuit. fixed Optional [ Params ] If True, no more components can be added to the subcircuit. Source code in nimphel/subcircuit.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 class Subckt : \"\"\"Class to handle a subcircuit. Attributes: name: Name of the subcircuit. components: List of component instances inside the subcircuit. ports: List of ports of the subcircuit. params: List of parameters of the subcircuit. fixed: If True, no more components can be added to the subcircuit. \"\"\" def __init__ ( self , name : str , ports : Ports , params : Optional [ Params ] = None , letter : Optional [ str ] = None , ): self . name : str = name self . letter = letter if letter else self . name [ 0 ] . upper () self . components : List [ Component ] = [] self . ports : Ports = ports self . params : Optional [ Params ] = params self . __fixed : bool = False nimphel . netlist . subcircuits [ self . name ] = self def __contains__ ( self , comp : Component ): return comp in self . components def fix ( self ): \"\"\"Fix the subcircuit to prevent adding more components.\"\"\" self . __fixed = True def add ( self , component : Union [ List [ Component ], Component ]): \"\"\"Add a component instance to the list of components. If the subcircuit is fixed, a warning is printed and nothing happens. Args: component: Component or list of components to add. \"\"\" if self . __fixed : print ( f \"WARNIG: Subcircuit { self . name } is fixed\" ) else : if isinstance ( component , list ): self . components += component else : self . components . append ( component ) def inst ( self , ports : Ports , params : Optional [ Params ] = None ) -> Component : \"\"\"Create a component instance from the subcircuit. Args: ports: Ports of the subcircuit instance. params: Parameters for the subcircuit instance. Returns: Component instance. Raises: KeyError: The number of ports given is checked against the defined ones. KeyError: There are default parameters that haven't been supplied. KeyError: The parameters given do not match the default ones. \"\"\" if len ( ports ) != len ( self . ports ): raise KeyError ( f \"Wrong number of ports supplied. \" f \"Needed { len ( self . ports ) } ports but { len ( ports ) } were given.\" ) nil_params : Params = {} if self . params : nil_params = { k : v for k , v in self . params . items () if v is None } if nil_params and params is None : raise KeyError ( f \"Must supply non default parameters. \" f \"Needed { list ( nil_params . keys ()) } \" ) if nil_params and params and ( params . keys () != nil_params . keys ()): raise KeyError ( f \"Parameters do not match with default params. \" f \"Needed { list ( nil_params . keys ()) } but got { list ( params . keys ()) } \" ) user_params = params if params else {} return Component ( ports , { ** nil_params , ** user_params }, name = self . name , letter = self . letter ) def to_dict ( self ) -> Dict [ str , Any ]: return { \"name\" : self . name , \"ports\" : self . ports , \"params\" : self . params , \"components\" : [ c . to_dict () for c in self . components ], \"fixed\" : self . __fixed , } def to_json ( self ) -> str : return json . dumps ( self . to_dict ()) @classmethod def from_json ( cls , json_str : str ) -> Subckt : data = json . loads ( json_str ) subckt = cls ( name = data . get ( \"name\" ), ports = data . get ( \"ports\" ), letter = data . get ( \"letter\" , None ), params = data . get ( \"params\" , None ), ) def make_component ( data ): return Component . from_json ( json . dumps ( data )) subckt . components = [ make_component ( c ) for c in data . get ( \"components\" , [])] if data . get ( \"fixed\" , False ): subckt . fix () return subckt add ( component ) Add a component instance to the list of components. If the subcircuit is fixed, a warning is printed and nothing happens. Parameters: Name Type Description Default component Union [ List [ Component ], Component ] Component or list of components to add. required Source code in nimphel/subcircuit.py 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 def add ( self , component : Union [ List [ Component ], Component ]): \"\"\"Add a component instance to the list of components. If the subcircuit is fixed, a warning is printed and nothing happens. Args: component: Component or list of components to add. \"\"\" if self . __fixed : print ( f \"WARNIG: Subcircuit { self . name } is fixed\" ) else : if isinstance ( component , list ): self . components += component else : self . components . append ( component ) fix () Fix the subcircuit to prevent adding more components. Source code in nimphel/subcircuit.py 43 44 45 def fix ( self ): \"\"\"Fix the subcircuit to prevent adding more components.\"\"\" self . __fixed = True inst ( ports , params = None ) Create a component instance from the subcircuit. Parameters: Name Type Description Default ports Ports Ports of the subcircuit instance. required params Optional [ Params ] Parameters for the subcircuit instance. None Returns: Type Description Component Component instance. Raises: Type Description KeyError The number of ports given is checked against the defined ones. KeyError There are default parameters that haven't been supplied. KeyError The parameters given do not match the default ones. Source code in nimphel/subcircuit.py 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 def inst ( self , ports : Ports , params : Optional [ Params ] = None ) -> Component : \"\"\"Create a component instance from the subcircuit. Args: ports: Ports of the subcircuit instance. params: Parameters for the subcircuit instance. Returns: Component instance. Raises: KeyError: The number of ports given is checked against the defined ones. KeyError: There are default parameters that haven't been supplied. KeyError: The parameters given do not match the default ones. \"\"\" if len ( ports ) != len ( self . ports ): raise KeyError ( f \"Wrong number of ports supplied. \" f \"Needed { len ( self . ports ) } ports but { len ( ports ) } were given.\" ) nil_params : Params = {} if self . params : nil_params = { k : v for k , v in self . params . items () if v is None } if nil_params and params is None : raise KeyError ( f \"Must supply non default parameters. \" f \"Needed { list ( nil_params . keys ()) } \" ) if nil_params and params and ( params . keys () != nil_params . keys ()): raise KeyError ( f \"Parameters do not match with default params. \" f \"Needed { list ( nil_params . keys ()) } but got { list ( params . keys ()) } \" ) user_params = params if params else {} return Component ( ports , { ** nil_params , ** user_params }, name = self . name , letter = self . letter ) Circuit Class to handle the state of the circuit. Attributes: Name Type Description instances Dict to track component ids. components List [ Component ] List of component instances. subcircuits Dict [ str , Subckt ] Dict to track subcircuit definitions. nets int Counter to keep track of the nets. exporter int Exporter used to create the netlist. Source code in nimphel/circuit.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 class Circuit : \"\"\"Class to handle the state of the circuit. Attributes: instances: Dict to track component ids. components: List of component instances. subcircuits: Dict to track subcircuit definitions. nets: Counter to keep track of the nets. exporter: Exporter used to create the netlist. \"\"\" def __init__ ( self ): self . instances = defaultdict ( int ) self . components : List [ Component ] = [] self . subcircuits : Dict [ str , Subckt ] = {} self . nets : int = 0 def add ( self , component : Union [ np . ndarray , Tuple [ Component ], List [ Component ], Component ], ): \"\"\"Add a component instance to the circuit. Args: component: Component or list of component instances. \"\"\" if isinstance ( component , np . ndarray ): self . components += np . ravel ( component ) . tolist () elif isinstance ( component , ( tuple , list )): self . components += component else : self . components . append ( component ) def __contains__ ( self , inst : Union [ Component , Subckt ]) -> bool : \"\"\"Checks if a component or subcircuit is present inside the circuit. Args: inst: Component or subcircuit to check. Returns: True if the instance is inside the circuit. \"\"\" if isinstance ( inst , Component ): return inst in self . components return inst in self . subcircuits or any ( inst . name == c . name for c in self . components ) def into_subckt ( self , name : str , ports : Ports , params : Optional [ Params ] = None ) -> Subckt : \"\"\"Convert the state into a subcircuit. Args: name: Name of the subcircuit. ports: Ports of the subcircuit. params: Parameters of the subcircuit. Returns: Subcircuit Todo: * This subckt will register itself to the global netlist. Make this optional or prevent it from happening? \"\"\" subckt = Subckt ( name , ports , params if params else {}) subckt . add ( self . components ) return subckt def export ( self , exporter : Exporter ) -> str : \"\"\"Export the current circuit. Args: exporter: Exporter class to use. Returns: The formated circuit as a string. \"\"\" subckts = \" \\n \" . join ( map ( exporter . fmt_subckt , self . subcircuits . values ())) components = \" \\n \" . join ( map ( exporter . fmt_component , self . components )) return f \" { subckts } \\n { components } \\n \" def export_to_file ( self , outfile : Union [ str , bytes , PathLike ], exporter : Exporter ): \"\"\"Export the netlist directly to a file. Args: outfile: Path to the file. \"\"\" with open ( outfile , \"w+\" ) as file : file . write ( self . export ( exporter )) def to_dict ( self ) -> Dict [ str , Any ]: \"\"\"Export a circuit to a dict\"\"\" return { \"instances\" : dict ( self . instances ), \"components\" : [ c . to_dict () for c in self . components ], \"subcircuits\" : { k : v . to_dict () for k , v in self . subcircuits . items ()}, \"nets\" : self . nets , } def to_json ( self ) -> str : \"\"\"Returns the string representation of the component.\"\"\" return json . dumps ( self . to_dict ()) @classmethod def from_json ( cls , json_str : str ) -> Circuit : \"\"\" \"\"\" data = json . loads ( json_str ) circuit = cls () circuit . instances = defaultdict ( int , data . get ( \"instances\" , {})) def create ( sub_cls : type , data : dict [ str , Any ]): \"\"\"Wrapper to call from_json on both Component and Subcircuit.\"\"\" return sub_cls . from_json ( json . dumps ( data )) circuit . components = [ create ( Component , c ) for c in data . get ( \"components\" )] circuit . subcircuits = { name : create ( Subckt , c ) for name , c in data . get ( \"subcircuits\" ) . items () } circuit . nets = data . get ( \"nets\" , 0 ) return circuit def to_graph ( self , comps : Optional [ List [ Component ]] = None , root : Optional [ str ] = None , * , name : str = \"circuit\" , ) -> nx . Graph : \"\"\"Create a graph with the instances in the circuit. This functions adds connections between the root and every component instance. If the component instance is a subcircuit, this function gets called again with the subcircuit as the root node. The weight between the connections represents the number of components that are inside a circuit or subcircuit, that is, the dependencies. The dependencies are normalized for just one subcircuit. To know the real number of instances in the total circuit, see ``count_instances``. By default the root of the circuit is called `circuit`. This root name can be changed with the `name` argument. Args: comps: List of component instances. root: Name of the node that serves as the root. name: Name of the global root. Defaults to 'circuit'. Returns: The generated graph with all components, subcircuits and the circuit. \"\"\" circuit_graph , visited = nx . Graph (), set () if root is None : circuit_graph . add_node ( name , color = \"yellow\" ) root = name components = comps if comps else self . components instances = Counter ([ c . name for c in components ]) for comp_name , count in instances . items (): if name in visited : continue subckt = self . subcircuits . get ( comp_name , None ) if subckt : circuit_graph . add_node ( subckt . name , color = \"orange\" ) circuit_graph . add_edge ( root , subckt . name , weight = count ) graph = self . to_graph ( subckt . components , root = subckt . name ) circuit_graph = nx . compose ( circuit_graph , graph ) else : # Simple component circuit_graph . add_node ( comp_name , color = \"red\" ) circuit_graph . add_edge ( root , comp_name , weight = count ) visited . add ( comp_name ) return circuit_graph def count_instances ( self , root = \"circuit\" ) -> Dict [ str , int ]: \"\"\"Count the number of instances in the circuit. This functions calculates the total number of instances by traversing the graph generated with the method ``to_graph``. Args: root: Name of the root node. Has to match the one passed to 'to_graph'. Returns: A dict containing the instance name and the respective global count. \"\"\" instances : Dict [ str , int ] = {} graph = self . to_graph () for node in map ( lambda n : n [ 0 ], graph . nodes ( data = True )): is_subckt = node in self . subcircuits if node == root : continue valid_paths = [] for path in nx . all_simple_paths ( graph , source = root , target = node ): route , edges = [], list ( nx . utils . pairwise ( path )) for ( start , end ) in edges : if start == root : route . append (( start , end )) continue if is_subckt : if not end in self . subcircuits : route . clear () break route . append (( start , end )) else : if not start in self . subcircuits and end in self . subcircuits : route . clear () break route . append (( start , end )) valid_paths . append ( route ) count = 0 for path in filter ( bool , valid_paths ): count_path = 1 for start , end in path : data = graph . get_edge_data ( start , end ) count_path *= data [ \"weight\" ] count += count_path instances [ node ] = count return instances __contains__ ( inst ) Checks if a component or subcircuit is present inside the circuit. Parameters: Name Type Description Default inst Union [ Component , Subckt ] Component or subcircuit to check. required Returns: Type Description bool True if the instance is inside the circuit. Source code in nimphel/circuit.py 53 54 55 56 57 58 59 60 61 62 63 64 65 66 def __contains__ ( self , inst : Union [ Component , Subckt ]) -> bool : \"\"\"Checks if a component or subcircuit is present inside the circuit. Args: inst: Component or subcircuit to check. Returns: True if the instance is inside the circuit. \"\"\" if isinstance ( inst , Component ): return inst in self . components return inst in self . subcircuits or any ( inst . name == c . name for c in self . components ) add ( component ) Add a component instance to the circuit. Parameters: Name Type Description Default component Union [ np . ndarray , Tuple [ Component ], List [ Component ], Component ] Component or list of component instances. required Source code in nimphel/circuit.py 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 def add ( self , component : Union [ np . ndarray , Tuple [ Component ], List [ Component ], Component ], ): \"\"\"Add a component instance to the circuit. Args: component: Component or list of component instances. \"\"\" if isinstance ( component , np . ndarray ): self . components += np . ravel ( component ) . tolist () elif isinstance ( component , ( tuple , list )): self . components += component else : self . components . append ( component ) count_instances ( root = 'circuit' ) Count the number of instances in the circuit. This functions calculates the total number of instances by traversing the graph generated with the method to_graph . Parameters: Name Type Description Default root Name of the root node. Has to match the one passed to 'to_graph'. 'circuit' Returns: Type Description Dict [ str , int ] A dict containing the instance name and the respective global count. Source code in nimphel/circuit.py 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 def count_instances ( self , root = \"circuit\" ) -> Dict [ str , int ]: \"\"\"Count the number of instances in the circuit. This functions calculates the total number of instances by traversing the graph generated with the method ``to_graph``. Args: root: Name of the root node. Has to match the one passed to 'to_graph'. Returns: A dict containing the instance name and the respective global count. \"\"\" instances : Dict [ str , int ] = {} graph = self . to_graph () for node in map ( lambda n : n [ 0 ], graph . nodes ( data = True )): is_subckt = node in self . subcircuits if node == root : continue valid_paths = [] for path in nx . all_simple_paths ( graph , source = root , target = node ): route , edges = [], list ( nx . utils . pairwise ( path )) for ( start , end ) in edges : if start == root : route . append (( start , end )) continue if is_subckt : if not end in self . subcircuits : route . clear () break route . append (( start , end )) else : if not start in self . subcircuits and end in self . subcircuits : route . clear () break route . append (( start , end )) valid_paths . append ( route ) count = 0 for path in filter ( bool , valid_paths ): count_path = 1 for start , end in path : data = graph . get_edge_data ( start , end ) count_path *= data [ \"weight\" ] count += count_path instances [ node ] = count return instances export ( exporter ) Export the current circuit. Parameters: Name Type Description Default exporter Exporter Exporter class to use. required Returns: Type Description str The formated circuit as a string. Source code in nimphel/circuit.py 89 90 91 92 93 94 95 96 97 98 99 100 def export ( self , exporter : Exporter ) -> str : \"\"\"Export the current circuit. Args: exporter: Exporter class to use. Returns: The formated circuit as a string. \"\"\" subckts = \" \\n \" . join ( map ( exporter . fmt_subckt , self . subcircuits . values ())) components = \" \\n \" . join ( map ( exporter . fmt_component , self . components )) return f \" { subckts } \\n { components } \\n \" export_to_file ( outfile , exporter ) Export the netlist directly to a file. Parameters: Name Type Description Default outfile Union [ str , bytes , PathLike ] Path to the file. required Source code in nimphel/circuit.py 102 103 104 105 106 107 108 109 def export_to_file ( self , outfile : Union [ str , bytes , PathLike ], exporter : Exporter ): \"\"\"Export the netlist directly to a file. Args: outfile: Path to the file. \"\"\" with open ( outfile , \"w+\" ) as file : file . write ( self . export ( exporter )) into_subckt ( name , ports , params = None ) Convert the state into a subcircuit. Parameters: Name Type Description Default name str Name of the subcircuit. required ports Ports Ports of the subcircuit. required params Optional [ Params ] Parameters of the subcircuit. None Returns: Type Description Subckt Subcircuit Todo This subckt will register itself to the global netlist. Make this optional or prevent it from happening? Source code in nimphel/circuit.py 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 def into_subckt ( self , name : str , ports : Ports , params : Optional [ Params ] = None ) -> Subckt : \"\"\"Convert the state into a subcircuit. Args: name: Name of the subcircuit. ports: Ports of the subcircuit. params: Parameters of the subcircuit. Returns: Subcircuit Todo: * This subckt will register itself to the global netlist. Make this optional or prevent it from happening? \"\"\" subckt = Subckt ( name , ports , params if params else {}) subckt . add ( self . components ) return subckt to_dict () Export a circuit to a dict Source code in nimphel/circuit.py 111 112 113 114 115 116 117 118 def to_dict ( self ) -> Dict [ str , Any ]: \"\"\"Export a circuit to a dict\"\"\" return { \"instances\" : dict ( self . instances ), \"components\" : [ c . to_dict () for c in self . components ], \"subcircuits\" : { k : v . to_dict () for k , v in self . subcircuits . items ()}, \"nets\" : self . nets , } to_graph ( comps = None , root = None , * , name = 'circuit' ) Create a graph with the instances in the circuit. This functions adds connections between the root and every component instance. If the component instance is a subcircuit, this function gets called again with the subcircuit as the root node. The weight between the connections represents the number of components that are inside a circuit or subcircuit, that is, the dependencies. The dependencies are normalized for just one subcircuit. To know the real number of instances in the total circuit, see count_instances . By default the root of the circuit is called circuit . This root name can be changed with the name argument. Parameters: Name Type Description Default comps Optional [ List [ Component ]] List of component instances. None root Optional [ str ] Name of the node that serves as the root. None name str Name of the global root. Defaults to 'circuit'. 'circuit' Returns: Type Description nx . Graph The generated graph with all components, subcircuits and the circuit. Source code in nimphel/circuit.py 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 def to_graph ( self , comps : Optional [ List [ Component ]] = None , root : Optional [ str ] = None , * , name : str = \"circuit\" , ) -> nx . Graph : \"\"\"Create a graph with the instances in the circuit. This functions adds connections between the root and every component instance. If the component instance is a subcircuit, this function gets called again with the subcircuit as the root node. The weight between the connections represents the number of components that are inside a circuit or subcircuit, that is, the dependencies. The dependencies are normalized for just one subcircuit. To know the real number of instances in the total circuit, see ``count_instances``. By default the root of the circuit is called `circuit`. This root name can be changed with the `name` argument. Args: comps: List of component instances. root: Name of the node that serves as the root. name: Name of the global root. Defaults to 'circuit'. Returns: The generated graph with all components, subcircuits and the circuit. \"\"\" circuit_graph , visited = nx . Graph (), set () if root is None : circuit_graph . add_node ( name , color = \"yellow\" ) root = name components = comps if comps else self . components instances = Counter ([ c . name for c in components ]) for comp_name , count in instances . items (): if name in visited : continue subckt = self . subcircuits . get ( comp_name , None ) if subckt : circuit_graph . add_node ( subckt . name , color = \"orange\" ) circuit_graph . add_edge ( root , subckt . name , weight = count ) graph = self . to_graph ( subckt . components , root = subckt . name ) circuit_graph = nx . compose ( circuit_graph , graph ) else : # Simple component circuit_graph . add_node ( comp_name , color = \"red\" ) circuit_graph . add_edge ( root , comp_name , weight = count ) visited . add ( comp_name ) return circuit_graph to_json () Returns the string representation of the component. Source code in nimphel/circuit.py 120 121 122 def to_json ( self ) -> str : \"\"\"Returns the string representation of the component.\"\"\" return json . dumps ( self . to_dict ()) create_graph ( graph ) Create the plot to visualize the graph generated by a circuit. Matplotlib.pyplot needs to be imported and the function show needs to be called in order to visualize the plot. Parameters: Name Type Description Default graph nx . Graph The circuit graph to plot. required Source code in nimphel/circuit.py 240 241 242 243 244 245 246 247 248 249 250 251 252 def create_graph ( graph : nx . Graph ): \"\"\"Create the plot to visualize the graph generated by a circuit. `Matplotlib.pyplot` needs to be imported and the function `show` needs to be called in order to visualize the plot. Args: graph: The circuit graph to plot. \"\"\" pos = nx . spring_layout ( graph ) color_map = [ data [ \"color\" ] for ( name , data ) in graph . nodes ( data = True )] nx . draw_networkx ( graph , pos , with_labels = True , node_color = color_map ) labels = nx . get_edge_attributes ( graph , \"weight\" ) nx . draw_networkx_edge_labels ( graph , pos , edge_labels = labels ) cast_value ( val ) Cast a string to an int, or float or string. The value is casted to int. If it fails it is casted to float and if that fails, the value is returned without modification. Parameters: Name Type Description Default val str Value we want to cast required Returns: Type Description ParamValue The value casted to the type. Source code in nimphel/parsers.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 def cast_value ( val : str ) -> ParamValue : \"\"\"Cast a string to an int, or float or string. The value is casted to int. If it fails it is casted to float and if that fails, the value is returned without modification. Args: val: Value we want to cast Returns: The value casted to the type. \"\"\" for t in [ int , float ]: try : value = t ( val ) return value except ValueError : pass return val eldo_parser ( lib ) Parser for eldo technology files. Parameters: Name Type Description Default lib TextIO Path to the lib file. required Returns: Type Description Dict [ str , Model ] Dictionary containing the models in the file. Source code in nimphel/parsers.py 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 def eldo_parser ( lib : TextIO ) -> Dict [ str , Model ]: \"\"\"Parser for eldo technology files. Args: lib: Path to the lib file. Returns: Dictionary containing the models in the file. \"\"\" re_subckt = re . compile ( r \"\\.subckt (\\w+) .*\" ) models : Dict [ str , Model ] = {} lines = iter ([ l . strip () for l in lib . readlines ()]) line = next ( lines ) while lines : while not re_subckt . search ( line ): try : line = next ( lines ) except StopIteration : return models subckt_name = re_subckt . search ( line ) . group ( 1 ) while not line . startswith ( \"+\" ): line = next ( lines ) param_lines = [] while line . startswith ( \"+\" ): param_lines . append ( line [ 1 :] . strip ()) line = next ( lines ) params = {} parameters = \" \" . join ( param_lines ) for param in parameters [ 6 :] . split ( \" \" ): name , value = param . split ( \"=\" ) params [ name ] = cast_value ( value ) models [ subckt_name ] = Model ( subckt_name , params ) return models parse_model_file ( file_path , parser ) Parse a technology file using the given parser Parameters: Name Type Description Default file_path PathLike Path to the technology file. required parser Parser Parser to use in the file. required Returns: Type Description Dict [ str , Model ] Dictionary containing the models in the file. Source code in nimphel/parsers.py 174 175 176 177 178 179 180 181 182 183 184 def parse_model_file ( file_path : PathLike , parser : Parser ) -> Dict [ str , Model ]: \"\"\"Parse a technology file using the given parser Args: file_path: Path to the technology file. parser: Parser to use in the file. Returns: Dictionary containing the models in the file. \"\"\" with open ( file_path , \"r\" ) as f : return parser ( f ) spectre_parser ( lib ) Parser for spectre technology files. Parameters: Name Type Description Default lib TextIO Path to the lib file. required Returns: Type Description Dict [ str , Model ] Dictionary containing the models in the file. Source code in nimphel/parsers.py 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 def spectre_parser ( lib : TextIO ) -> Dict [ str , Model ]: \"\"\"Parser for spectre technology files. Args: lib: Path to the lib file. Returns: Dictionary containing the models in the file. \"\"\" re_subckt = re . compile ( r \"subckt (\\w+) .*\" ) re_param = re . compile ( r \"\\+ (\\w+) = (.*)\" ) models : Dict [ str , Model ] = {} lines = iter ([ l . strip () for l in lib . readlines ()]) line = next ( lines ) while lines : while not re_subckt . search ( line ): try : line = next ( lines ) except StopIteration : return models subckt_name = re_subckt . search ( line ) . group ( 1 ) while not re_param . search ( line ): line = next ( lines ) params = {} while not re_param . search ( line ): line = next ( lines ) while re_param . search ( line ): name , value = re_param . search ( line ) . groups () params [ name ] = cast_value ( value ) line = next ( lines ) models [ subckt_name ] = Model ( subckt_name , params ) return models veriloga_parser ( lib ) Parser for verilogA files. Parameters: Name Type Description Default lib TextIO Path to the lib file. required Returns: Type Description Dict [ str , Model ] Dictionary containing the models in the file. Source code in nimphel/parsers.py 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 def veriloga_parser ( lib : TextIO ) -> Dict [ str , Model ]: \"\"\"Parser for verilogA files. Args: lib: Path to the lib file. Returns: Dictionary containing the models in the file. \"\"\" models : Dict [ str , Model ] = {} lines = iter ([ l . strip () for l in lib . readlines ()]) param_re = re . compile ( r \".*parameter \\w+ (\\w+) = (.*);\" ) module_re = re . compile ( r \".*module (\\w+) .*;\" ) line = next ( lines ) while lines : while not module_re . search ( line ): try : line = next ( lines ) except StopIteration : return models module_name = module_re . search ( line ) . group ( 1 ) params = {} while not line . startswith ( \"analog begin\" ): line = next ( lines ) if param_re . search ( line ): name , value = param_re . search ( line ) . groups () params [ name ] = cast_value ( value . replace ( '\"' , \"\" )) models [ module_name ] = Model ( module_name , params ) return models yaml_parser ( lib ) Parser for YAML files. Parameters: Name Type Description Default lib str Path to the lib file. required Returns: Type Description Dict [ str , Model ] Dictionary containing the models in the file. Source code in nimphel/parsers.py 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 def yaml_parser ( lib : str ) -> Dict [ str , Model ]: \"\"\"Parser for YAML files. Args: lib: Path to the lib file. Returns: Dictionary containing the models in the file. \"\"\" models : Dict [ str , Model ] = {} for config in yaml . load_all ( lib , Loader = yaml . Loader ): if config [ \"params\" ] . get ( \"from\" , False ): name = config [ \"params\" ][ \"from\" ] new_vals = { k : v for k , v in config . items () if k != \"from\" } params = { ** models [ name ] . params , ** new_vals } params = { k : v for k , v in params . items () if v } models [ config [ \"name\" ]] = Model ( name , params ) else : models [ config [ \"name\" ]] = Model ( ** config ) return models Exporter Interface for a Exporter. An exporter needs to implement functions to format a component instance, a subcircuit and a net. Source code in nimphel/exporters.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Exporter : \"\"\"Interface for a Exporter. An exporter needs to implement functions to format a component instance, a subcircuit and a net. \"\"\" def fmt_component ( self , comp ) -> str : \"\"\"Format a component instance.\"\"\" raise NotImplementedError def fmt_subckt ( self , subckt ) -> str : \"\"\"Format a subcircuit definition.\"\"\" raise NotImplementedError def fmt_net ( self , net ) -> str : \"\"\"Format a net.\"\"\" raise NotImplementedError fmt_component ( comp ) Format a component instance. Source code in nimphel/exporters.py 19 20 21 def fmt_component ( self , comp ) -> str : \"\"\"Format a component instance.\"\"\" raise NotImplementedError fmt_net ( net ) Format a net. Source code in nimphel/exporters.py 27 28 29 def fmt_net ( self , net ) -> str : \"\"\"Format a net.\"\"\" raise NotImplementedError fmt_subckt ( subckt ) Format a subcircuit definition. Source code in nimphel/exporters.py 23 24 25 def fmt_subckt ( self , subckt ) -> str : \"\"\"Format a subcircuit definition.\"\"\" raise NotImplementedError SpectreExporter Bases: Exporter Exporter implementation for Spectre Source code in nimphel/exporters.py 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 class SpectreExporter ( Exporter ): \"\"\"Exporter implementation for Spectre\"\"\" def __fmt_value ( self , value ): if isinstance ( value , list ): return f '[ { \" \" . join ( map ( str , value )) } ]' if isinstance ( value , ( float , int )): return f \" { value : .2F } \" return f '\" { value } \"' def fmt_component ( self , comp ) -> str : if hasattr ( comp , \"fmt\" ): return comp . fmt () ports = \" \" . join ( map ( self . fmt_net , comp . ports )) params_not_nil = { k : v for k , v in comp . params . items () if v } params = \" \" . join ( [ f \" { k } = { self . __fmt_value ( v ) } \" for k , v in params_not_nil . items ()] ) return f \" { comp . letter }{ comp . num_id } ( { ports } ) { comp . name } { params } \" def fmt_subckt ( self , subckt ) -> str : comps = \" \\n \" . join ( map ( self . fmt_component , subckt . components )) ports = \" \" . join ( map ( self . fmt_net , subckt . ports )) nil_params = [ f \" { k } \" for k , v in subckt . params . items () if not v ] val_params = [ f \" { k } = { v } \" for k , v in subckt . params . items () if v ] if val_params or nil_params : params = f \"parameters { ' ' . join ( nil_params + val_params ) } \\n \" else : params = \"\" return ( f \"subckt { subckt . name } { ports } \\n \" f \" { params } \" f \" { comps } \\n \" f \"ends { subckt . name } \\n \" ) def fmt_net ( self , net : Union [ str , int ]) -> str : if isinstance ( net , int ): return f \"net { net } \" return net models_to_yaml ( models , out_path ) models: out_path: Source code in nimphel/exporters.py 75 76 77 78 79 80 81 82 83 def models_to_yaml ( models : Dict [ str , Model ], out_path : PathLike ): \"\"\" Args: models: out_path: \"\"\" data = [{ \"name\" : name , \"params\" : model . params } for name , model in models . items ()] with open ( out_path , \"w+\" ) as f : f . write ( yaml . dump_all ( data , Dumper = yaml . Dumper ))","title":"API Reference"},{"location":"api/#nimphel.component.Component","text":"Class to save component instances. There can be no two instances of the same component with the same id, except if one of them is inside a subcircuit. The name of the device is the first not null name in the list of names. The list of names han the following priority User defined name. Model name. Name of the subclass. Attributes: Name Type Description num_id Numeric id given to the instance. name str Name of the component instance. ports List of ports of the component. params Dict of parameters using the model parameters as default if provided. Raises: Type Description AttributeError The list of ports is empty Source code in nimphel/component.py 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 class Component : \"\"\"Class to save component instances. There can be no two instances of the same component with the same id, except if one of them is inside a subcircuit. The name of the device is the first not null name in the list of names. The list of names han the following priority: 1. User defined name. 2. Model name. 3. Name of the subclass. Attributes: num_id: Numeric id given to the instance. name: Name of the component instance. ports: List of ports of the component. params: Dict of parameters using the model parameters as default if provided. Raises: AttributeError: The list of ports is empty \"\"\" def __init__ ( self , ports : Ports , params : Optional [ Params ] = None , name : Optional [ str ] = None , letter : Optional [ str ] = None , model : Optional [ Model ] = None , ): self . _name = [ name , model . name if model else None , type ( self ) . __name__ ] self . letter = letter if letter else self . name [ 0 ] . upper () if not ports : raise ValueError ( f \"Ports for { self . name } cannot empty.\" ) self . ports = ports self . num_id = nimphel . netlist . instances [ self . name ] nimphel . netlist . instances [ self . name ] += 1 self . model = model user_params = params if params else {} if model : self . params = { ** model . params , ** user_params } else : self . params = user_params @property def name ( self ) -> str : \"\"\"Returns the name of the component. Returns: The actual name of the device. \"\"\" return next ( filter ( bool , self . _name ), \"\" ) @name . setter def name ( self , name : str ): \"\"\"The name is set as a user defined name.\"\"\" self . _name [ 0 ] = name @classmethod def from_dict ( cls , data : Dict [ str , Any ]) -> Component : \"\"\"Create a component from a Dictionaly.\"\"\" model = data . get ( \"model\" , None ) if model : model = Model ( ** model ) return cls ( data [ \"ports\" ], params = data . get ( \"params\" , {}), name = data . get ( \"name\" , None ), letter = data . get ( \"letter\" , None ), model = model , ) @classmethod def from_json ( cls , json_str : str ) -> Component : \"\"\"Create a component from a JSON string.\"\"\" data = json . loads ( json_str ) model = data . get ( \"model\" , None ) if model : model = Model ( ** model ) return cls ( data [ \"ports\" ], params = data . get ( \"params\" , {}), name = data . get ( \"name\" , None ), letter = data . get ( \"letter\" , None ), model = model , ) def to_json ( self ) -> str : \"\"\"Returns the string representation of the component.\"\"\" return json . dumps ( self . to_dict ()) def __pos__ ( self ) -> Component : \"\"\"Make a copy and increment the id of the new component. The component is copied using deepcopy. Returns: The new component with num_id increased by 1. \"\"\" other = copy . deepcopy ( self ) other . num_id += 1 nimphel . netlist . instances [ self . name ] += 1 return other def loop ( self , mask : Optional [ Tuple [ int , ... ]] = None ) -> Tuple [ Component , Component ]: \"\"\"Create a self loop of a component given a mask. Example: Given a component with ports [IN, VDD, OUT, GND] and mask (1, 0, 1, 0), loop will return a list of components with ports [IN, VDD, OUT, GND] and [OUT, VDD, IN, GND] Args: mask: Mask to select the two ports to loop. If None, use the first two ports. Returns: Tuple containing both elements of the loop. Raises: ValueError: The mask has more or less than two ports selected. \"\"\" if len ( self . ports ) < 2 : raise ValueError ( \"Component cannot self loop as it only has one port.\" ) if mask is None : mask = ( 1 , 1 ) + ( 0 ,) * max ( len ( self . ports ), 0 ) elif sum ( mask ) != 2 : raise ValueError ( \"Two ports are needed to create a self loop.\" ) other = + self first = mask . index ( 1 ) second = mask . index ( 1 , first + 1 ) other . ports [ first ], other . ports [ second ] = ( other . ports [ second ], other . ports [ first ], ) return ( self , other ) def __invert__ ( self ) -> Tuple [ Component , Component ]: \"\"\"Create a self loop of a component. Overloaded operator for ``loop``\"\"\" return self . loop () def __lshift__ ( self , val : int ): \"\"\"Shift the ports in the left direction.\"\"\" self . ports = self . ports [: val ] + self . ports [ val :] def __rshift__ ( self , val : int ): \"\"\"Shift the ports in the right direction.\"\"\" self . __lshift__ ( - val ) def chain ( self , val : Union [ int , Tuple [ Net , ... ], Tuple [ int , Callable [[ int ], str ]]], mask : Optional [ Mask ] = None , ) -> List [ Component ]: \"\"\"If val is a tuple, various things can happen. First, len(tuple) == len(comp.ports) If the value is 0, that port is fixed and does not change. If the value is 1, that port is used for chaining, from left to right. comp * (0, 0, 1, 1) Following the left to right rule, if the values are strings, they will be used for the first and last name of the nets. comp * (0, 0, \"first\", \"out\") The user can also supply a function instead of a str or int. The function will be given the index of the chain and should return a net. comp * (0, 0, \"Input\", lambda d: f'net{d}') If val is an int, chain `val` times as normal, that is (in, out) -> (out, net()) -> ... -> (net(), net()) Only the global state keeps track of the updated ids, this means that the original component mantains it's id. Args: val: mask: Returns: List containing the chain of components. TODO: * Use the mask to select the ports \"\"\" components = [ self ] if isinstance ( val , tuple ): nelem = val [ 0 ] if isinstance ( val [ 1 ], Callable ): last_name = val [ 1 ] else : last_name = lambda : val [ 1 ] else : nelem = val last_name = net _ , * unchanged , last_port = self . ports new_out = net () for i in range ( 1 , nelem ): new_ports = [ last_port , * unchanged , new_out ] new_comp = + components [ - 1 ] new_comp . ports = new_ports components . append ( new_comp ) if i != ( nelem - 2 ): last_port , new_out = new_out , net () else : last_port , new_out = new_out , last_name () return components def __mul__ ( self , val : Union [ int , Tuple [ Net , ... ], Tuple [ int , Callable [[ int ], str ]]] ) -> List [ Component ]: \"\"\"Create components in a chain. Overloaded operator for ``chan``. \"\"\" return self . chain ( val ) def parallel ( self , val : int ) -> List [ Component ]: \"\"\"Create components in parallel. Components in parallel share the same input and output ports. Args: val: Number of components to create. Returns: List containing the components in parallel. \"\"\" components = [ self ] for _ in range ( 1 , val ): new_comp = + components [ - 1 ] components . append ( new_comp ) return components def __or__ ( self , val : int ) -> List [ Component ]: \"\"\"Create components in parallel. Overloaded operator for ``parallel``\"\"\" return self . parallel ( val ) def fanout ( self , val : int ) -> List [ Component ]: \"\"\"Create components with the same input and different output. Args: val: Number of components to create. Returns: List of components. \"\"\" self . ports [ - 1 ] = net () components = [ self ] for _ in range ( 1 , val ): new_comp = + components [ - 1 ] new_comp . ports [ - 1 ] = net () components . append ( new_comp ) return components def __xor__ ( self , val : int ) -> List [ Component ]: \"\"\"Create components with the same input and different output. Overloaded operator for ``fanout``.\"\"\" return self . fanout ( val ) def direct ( self , val : int ) -> List [ Component ]: \"\"\"Create components with the different inputs and same output. The first port of the component used to call the method gets modified. Args: val: Number of components to create. Returns: List of components. \"\"\" components = [ self ] for _ in range ( 1 , val ): new_comp = + components [ - 1 ] new_comp . ports [ 0 ] = net () components . append ( new_comp ) return components def __and__ ( self , val : int ) -> List [ Component ]: \"\"\"Create components with the different inputs and same output. Overloaded operator for ``direct``.\"\"\" return self . direct ( val ) def to_dict ( self ) -> Dict [ str , Any ]: \"\"\"Export a component to a dict\"\"\" model = None if not self . model else asdict ( self . model ) return { \"letter\" : self . letter , \"name\" : self . name , \"id\" : self . num_id , \"ports\" : self . ports , \"model\" : model , \"params\" : self . params , }","title":"Component"},{"location":"api/#nimphel.component.Component.__and__","text":"Create components with the different inputs and same output. Overloaded operator for direct . Source code in nimphel/component.py 341 342 343 344 def __and__ ( self , val : int ) -> List [ Component ]: \"\"\"Create components with the different inputs and same output. Overloaded operator for ``direct``.\"\"\" return self . direct ( val )","title":"__and__()"},{"location":"api/#nimphel.component.Component.__invert__","text":"Create a self loop of a component. Overloaded operator for loop Source code in nimphel/component.py 194 195 196 197 def __invert__ ( self ) -> Tuple [ Component , Component ]: \"\"\"Create a self loop of a component. Overloaded operator for ``loop``\"\"\" return self . loop ()","title":"__invert__()"},{"location":"api/#nimphel.component.Component.__lshift__","text":"Shift the ports in the left direction. Source code in nimphel/component.py 199 200 201 def __lshift__ ( self , val : int ): \"\"\"Shift the ports in the left direction.\"\"\" self . ports = self . ports [: val ] + self . ports [ val :]","title":"__lshift__()"},{"location":"api/#nimphel.component.Component.__mul__","text":"Create components in a chain. Overloaded operator for chan . Source code in nimphel/component.py 269 270 271 272 273 274 275 def __mul__ ( self , val : Union [ int , Tuple [ Net , ... ], Tuple [ int , Callable [[ int ], str ]]] ) -> List [ Component ]: \"\"\"Create components in a chain. Overloaded operator for ``chan``. \"\"\" return self . chain ( val )","title":"__mul__()"},{"location":"api/#nimphel.component.Component.__or__","text":"Create components in parallel. Overloaded operator for parallel Source code in nimphel/component.py 295 296 297 298 def __or__ ( self , val : int ) -> List [ Component ]: \"\"\"Create components in parallel. Overloaded operator for ``parallel``\"\"\" return self . parallel ( val )","title":"__or__()"},{"location":"api/#nimphel.component.Component.__pos__","text":"Make a copy and increment the id of the new component. The component is copied using deepcopy. Returns: Type Description Component The new component with num_id increased by 1. Source code in nimphel/component.py 147 148 149 150 151 152 153 154 155 156 157 158 def __pos__ ( self ) -> Component : \"\"\"Make a copy and increment the id of the new component. The component is copied using deepcopy. Returns: The new component with num_id increased by 1. \"\"\" other = copy . deepcopy ( self ) other . num_id += 1 nimphel . netlist . instances [ self . name ] += 1 return other","title":"__pos__()"},{"location":"api/#nimphel.component.Component.__rshift__","text":"Shift the ports in the right direction. Source code in nimphel/component.py 203 204 205 def __rshift__ ( self , val : int ): \"\"\"Shift the ports in the right direction.\"\"\" self . __lshift__ ( - val )","title":"__rshift__()"},{"location":"api/#nimphel.component.Component.__xor__","text":"Create components with the same input and different output. Overloaded operator for fanout . Source code in nimphel/component.py 317 318 319 320 def __xor__ ( self , val : int ) -> List [ Component ]: \"\"\"Create components with the same input and different output. Overloaded operator for ``fanout``.\"\"\" return self . fanout ( val )","title":"__xor__()"},{"location":"api/#nimphel.component.Component.chain","text":"If val is a tuple, various things can happen. First, len(tuple) == len(comp.ports) If the value is 0, that port is fixed and does not change. If the value is 1, that port is used for chaining, from left to right. comp * (0, 0, 1, 1) Following the left to right rule, if the values are strings, they will be used for the first and last name of the nets. comp * (0, 0, \"first\", \"out\") The user can also supply a function instead of a str or int. The function will be given the index of the chain and should return a net. comp * (0, 0, \"Input\", lambda d: f'net{d}') If val is an int, chain val times as normal, that is (in, out) -> (out, net()) -> ... -> (net(), net()) Only the global state keeps track of the updated ids, this means that the original component mantains it's id. Parameters: Name Type Description Default val Union [ int , Tuple [ Net , ...], Tuple [ int , Callable [[ int ], str ]]] required mask Optional [ Mask ] None Returns: Type Description List [ Component ] List containing the chain of components. TODO Use the mask to select the ports Source code in nimphel/component.py 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 def chain ( self , val : Union [ int , Tuple [ Net , ... ], Tuple [ int , Callable [[ int ], str ]]], mask : Optional [ Mask ] = None , ) -> List [ Component ]: \"\"\"If val is a tuple, various things can happen. First, len(tuple) == len(comp.ports) If the value is 0, that port is fixed and does not change. If the value is 1, that port is used for chaining, from left to right. comp * (0, 0, 1, 1) Following the left to right rule, if the values are strings, they will be used for the first and last name of the nets. comp * (0, 0, \"first\", \"out\") The user can also supply a function instead of a str or int. The function will be given the index of the chain and should return a net. comp * (0, 0, \"Input\", lambda d: f'net{d}') If val is an int, chain `val` times as normal, that is (in, out) -> (out, net()) -> ... -> (net(), net()) Only the global state keeps track of the updated ids, this means that the original component mantains it's id. Args: val: mask: Returns: List containing the chain of components. TODO: * Use the mask to select the ports \"\"\" components = [ self ] if isinstance ( val , tuple ): nelem = val [ 0 ] if isinstance ( val [ 1 ], Callable ): last_name = val [ 1 ] else : last_name = lambda : val [ 1 ] else : nelem = val last_name = net _ , * unchanged , last_port = self . ports new_out = net () for i in range ( 1 , nelem ): new_ports = [ last_port , * unchanged , new_out ] new_comp = + components [ - 1 ] new_comp . ports = new_ports components . append ( new_comp ) if i != ( nelem - 2 ): last_port , new_out = new_out , net () else : last_port , new_out = new_out , last_name () return components","title":"chain()"},{"location":"api/#nimphel.component.Component.direct","text":"Create components with the different inputs and same output. The first port of the component used to call the method gets modified. Parameters: Name Type Description Default val int Number of components to create. required Returns: Type Description List [ Component ] List of components. Source code in nimphel/component.py 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 def direct ( self , val : int ) -> List [ Component ]: \"\"\"Create components with the different inputs and same output. The first port of the component used to call the method gets modified. Args: val: Number of components to create. Returns: List of components. \"\"\" components = [ self ] for _ in range ( 1 , val ): new_comp = + components [ - 1 ] new_comp . ports [ 0 ] = net () components . append ( new_comp ) return components","title":"direct()"},{"location":"api/#nimphel.component.Component.fanout","text":"Create components with the same input and different output. Parameters: Name Type Description Default val int Number of components to create. required Returns: Type Description List [ Component ] List of components. Source code in nimphel/component.py 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 def fanout ( self , val : int ) -> List [ Component ]: \"\"\"Create components with the same input and different output. Args: val: Number of components to create. Returns: List of components. \"\"\" self . ports [ - 1 ] = net () components = [ self ] for _ in range ( 1 , val ): new_comp = + components [ - 1 ] new_comp . ports [ - 1 ] = net () components . append ( new_comp ) return components","title":"fanout()"},{"location":"api/#nimphel.component.Component.from_dict","text":"Create a component from a Dictionaly. Source code in nimphel/component.py 114 115 116 117 118 119 120 121 122 123 124 125 126 @classmethod def from_dict ( cls , data : Dict [ str , Any ]) -> Component : \"\"\"Create a component from a Dictionaly.\"\"\" model = data . get ( \"model\" , None ) if model : model = Model ( ** model ) return cls ( data [ \"ports\" ], params = data . get ( \"params\" , {}), name = data . get ( \"name\" , None ), letter = data . get ( \"letter\" , None ), model = model , )","title":"from_dict()"},{"location":"api/#nimphel.component.Component.from_json","text":"Create a component from a JSON string. Source code in nimphel/component.py 128 129 130 131 132 133 134 135 136 137 138 139 140 141 @classmethod def from_json ( cls , json_str : str ) -> Component : \"\"\"Create a component from a JSON string.\"\"\" data = json . loads ( json_str ) model = data . get ( \"model\" , None ) if model : model = Model ( ** model ) return cls ( data [ \"ports\" ], params = data . get ( \"params\" , {}), name = data . get ( \"name\" , None ), letter = data . get ( \"letter\" , None ), model = model , )","title":"from_json()"},{"location":"api/#nimphel.component.Component.loop","text":"Create a self loop of a component given a mask. Example Given a component with ports [IN, VDD, OUT, GND] and mask (1, 0, 1, 0), loop will return a list of components with ports [IN, VDD, OUT, GND] and [OUT, VDD, IN, GND] Parameters: Name Type Description Default mask Optional [ Tuple [ int , ...]] Mask to select the two ports to loop. If None, use the first two ports. None Returns: Type Description Tuple [ Component , Component ] Tuple containing both elements of the loop. Raises: Type Description ValueError The mask has more or less than two ports selected. Source code in nimphel/component.py 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 def loop ( self , mask : Optional [ Tuple [ int , ... ]] = None ) -> Tuple [ Component , Component ]: \"\"\"Create a self loop of a component given a mask. Example: Given a component with ports [IN, VDD, OUT, GND] and mask (1, 0, 1, 0), loop will return a list of components with ports [IN, VDD, OUT, GND] and [OUT, VDD, IN, GND] Args: mask: Mask to select the two ports to loop. If None, use the first two ports. Returns: Tuple containing both elements of the loop. Raises: ValueError: The mask has more or less than two ports selected. \"\"\" if len ( self . ports ) < 2 : raise ValueError ( \"Component cannot self loop as it only has one port.\" ) if mask is None : mask = ( 1 , 1 ) + ( 0 ,) * max ( len ( self . ports ), 0 ) elif sum ( mask ) != 2 : raise ValueError ( \"Two ports are needed to create a self loop.\" ) other = + self first = mask . index ( 1 ) second = mask . index ( 1 , first + 1 ) other . ports [ first ], other . ports [ second ] = ( other . ports [ second ], other . ports [ first ], ) return ( self , other )","title":"loop()"},{"location":"api/#nimphel.component.Component.name","text":"Returns the name of the component. Returns: Type Description str The actual name of the device. Source code in nimphel/component.py 100 101 102 103 104 105 106 107 @property def name ( self ) -> str : \"\"\"Returns the name of the component. Returns: The actual name of the device. \"\"\" return next ( filter ( bool , self . _name ), \"\" )","title":"name()"},{"location":"api/#nimphel.component.Component.parallel","text":"Create components in parallel. Components in parallel share the same input and output ports. Parameters: Name Type Description Default val int Number of components to create. required Returns: Type Description List [ Component ] List containing the components in parallel. Source code in nimphel/component.py 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 def parallel ( self , val : int ) -> List [ Component ]: \"\"\"Create components in parallel. Components in parallel share the same input and output ports. Args: val: Number of components to create. Returns: List containing the components in parallel. \"\"\" components = [ self ] for _ in range ( 1 , val ): new_comp = + components [ - 1 ] components . append ( new_comp ) return components","title":"parallel()"},{"location":"api/#nimphel.component.Component.to_dict","text":"Export a component to a dict Source code in nimphel/component.py 346 347 348 349 350 351 352 353 354 355 356 def to_dict ( self ) -> Dict [ str , Any ]: \"\"\"Export a component to a dict\"\"\" model = None if not self . model else asdict ( self . model ) return { \"letter\" : self . letter , \"name\" : self . name , \"id\" : self . num_id , \"ports\" : self . ports , \"model\" : model , \"params\" : self . params , }","title":"to_dict()"},{"location":"api/#nimphel.component.Component.to_json","text":"Returns the string representation of the component. Source code in nimphel/component.py 143 144 145 def to_json ( self ) -> str : \"\"\"Returns the string representation of the component.\"\"\" return json . dumps ( self . to_dict ())","title":"to_json()"},{"location":"api/#nimphel.component.Model","text":"A model holds default parameters for a specific type of component. Source code in nimphel/component.py 32 33 34 35 36 37 @dataclass class Model : \"\"\"A model holds default parameters for a specific type of component.\"\"\" name : str params : Dict [ str , ParamValue ]","title":"Model"},{"location":"api/#nimphel.component.net","text":"Generate a new global net. The number of nets is increased in the global circuit. Returns: Type Description int The new net. Source code in nimphel/component.py 40 41 42 43 44 45 46 47 48 49 def net () -> int : \"\"\"Generate a new global net. The number of nets is increased in the global circuit. Returns: The new net. \"\"\" nimphel . netlist . nets += 1 return int ( nimphel . netlist . nets - 1 )","title":"net()"},{"location":"api/#nimphel.component.simple_component","text":"Wrapper to create components that are very simple. Parameters: Name Type Description Default cls The class definition required Returns: Type Description The class to generate the specified component. Todo Add safety guards for the number of ports. Source code in nimphel/component.py 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 def simple_component ( cls ): \"\"\"Wrapper to create components that are very simple. Args: cls: The class definition Returns: The class to generate the specified component. Todo: * Add safety guards for the number of ports. \"\"\" cls_name = cls . __dict__ . get ( \"name\" , cls . __name__ ) cls_letter = cls . __dict__ . get ( \"letter\" , None ) cls_model = cls . __dict__ . get ( \"model\" , None ) def_params = cls . __dict__ . get ( \"defaults\" , {}) def init ( self , ports , params = None , model = None , name = None , letter = None ): user_params = {} if params is None else params super ( cls , self ) . __init__ ( ports , params = { ** def_params , ** user_params }, name = name or cls_name , letter = letter or cls_letter , model = model or cls_model , ) setattr ( cls , \"__init__\" , init ) return cls","title":"simple_component()"},{"location":"api/#nimphel.subcircuit.Subckt","text":"Class to handle a subcircuit. Attributes: Name Type Description name str Name of the subcircuit. components List [ Component ] List of component instances inside the subcircuit. ports Ports List of ports of the subcircuit. params Optional [ Params ] List of parameters of the subcircuit. fixed Optional [ Params ] If True, no more components can be added to the subcircuit. Source code in nimphel/subcircuit.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 class Subckt : \"\"\"Class to handle a subcircuit. Attributes: name: Name of the subcircuit. components: List of component instances inside the subcircuit. ports: List of ports of the subcircuit. params: List of parameters of the subcircuit. fixed: If True, no more components can be added to the subcircuit. \"\"\" def __init__ ( self , name : str , ports : Ports , params : Optional [ Params ] = None , letter : Optional [ str ] = None , ): self . name : str = name self . letter = letter if letter else self . name [ 0 ] . upper () self . components : List [ Component ] = [] self . ports : Ports = ports self . params : Optional [ Params ] = params self . __fixed : bool = False nimphel . netlist . subcircuits [ self . name ] = self def __contains__ ( self , comp : Component ): return comp in self . components def fix ( self ): \"\"\"Fix the subcircuit to prevent adding more components.\"\"\" self . __fixed = True def add ( self , component : Union [ List [ Component ], Component ]): \"\"\"Add a component instance to the list of components. If the subcircuit is fixed, a warning is printed and nothing happens. Args: component: Component or list of components to add. \"\"\" if self . __fixed : print ( f \"WARNIG: Subcircuit { self . name } is fixed\" ) else : if isinstance ( component , list ): self . components += component else : self . components . append ( component ) def inst ( self , ports : Ports , params : Optional [ Params ] = None ) -> Component : \"\"\"Create a component instance from the subcircuit. Args: ports: Ports of the subcircuit instance. params: Parameters for the subcircuit instance. Returns: Component instance. Raises: KeyError: The number of ports given is checked against the defined ones. KeyError: There are default parameters that haven't been supplied. KeyError: The parameters given do not match the default ones. \"\"\" if len ( ports ) != len ( self . ports ): raise KeyError ( f \"Wrong number of ports supplied. \" f \"Needed { len ( self . ports ) } ports but { len ( ports ) } were given.\" ) nil_params : Params = {} if self . params : nil_params = { k : v for k , v in self . params . items () if v is None } if nil_params and params is None : raise KeyError ( f \"Must supply non default parameters. \" f \"Needed { list ( nil_params . keys ()) } \" ) if nil_params and params and ( params . keys () != nil_params . keys ()): raise KeyError ( f \"Parameters do not match with default params. \" f \"Needed { list ( nil_params . keys ()) } but got { list ( params . keys ()) } \" ) user_params = params if params else {} return Component ( ports , { ** nil_params , ** user_params }, name = self . name , letter = self . letter ) def to_dict ( self ) -> Dict [ str , Any ]: return { \"name\" : self . name , \"ports\" : self . ports , \"params\" : self . params , \"components\" : [ c . to_dict () for c in self . components ], \"fixed\" : self . __fixed , } def to_json ( self ) -> str : return json . dumps ( self . to_dict ()) @classmethod def from_json ( cls , json_str : str ) -> Subckt : data = json . loads ( json_str ) subckt = cls ( name = data . get ( \"name\" ), ports = data . get ( \"ports\" ), letter = data . get ( \"letter\" , None ), params = data . get ( \"params\" , None ), ) def make_component ( data ): return Component . from_json ( json . dumps ( data )) subckt . components = [ make_component ( c ) for c in data . get ( \"components\" , [])] if data . get ( \"fixed\" , False ): subckt . fix () return subckt","title":"Subckt"},{"location":"api/#nimphel.subcircuit.Subckt.add","text":"Add a component instance to the list of components. If the subcircuit is fixed, a warning is printed and nothing happens. Parameters: Name Type Description Default component Union [ List [ Component ], Component ] Component or list of components to add. required Source code in nimphel/subcircuit.py 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 def add ( self , component : Union [ List [ Component ], Component ]): \"\"\"Add a component instance to the list of components. If the subcircuit is fixed, a warning is printed and nothing happens. Args: component: Component or list of components to add. \"\"\" if self . __fixed : print ( f \"WARNIG: Subcircuit { self . name } is fixed\" ) else : if isinstance ( component , list ): self . components += component else : self . components . append ( component )","title":"add()"},{"location":"api/#nimphel.subcircuit.Subckt.fix","text":"Fix the subcircuit to prevent adding more components. Source code in nimphel/subcircuit.py 43 44 45 def fix ( self ): \"\"\"Fix the subcircuit to prevent adding more components.\"\"\" self . __fixed = True","title":"fix()"},{"location":"api/#nimphel.subcircuit.Subckt.inst","text":"Create a component instance from the subcircuit. Parameters: Name Type Description Default ports Ports Ports of the subcircuit instance. required params Optional [ Params ] Parameters for the subcircuit instance. None Returns: Type Description Component Component instance. Raises: Type Description KeyError The number of ports given is checked against the defined ones. KeyError There are default parameters that haven't been supplied. KeyError The parameters given do not match the default ones. Source code in nimphel/subcircuit.py 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 def inst ( self , ports : Ports , params : Optional [ Params ] = None ) -> Component : \"\"\"Create a component instance from the subcircuit. Args: ports: Ports of the subcircuit instance. params: Parameters for the subcircuit instance. Returns: Component instance. Raises: KeyError: The number of ports given is checked against the defined ones. KeyError: There are default parameters that haven't been supplied. KeyError: The parameters given do not match the default ones. \"\"\" if len ( ports ) != len ( self . ports ): raise KeyError ( f \"Wrong number of ports supplied. \" f \"Needed { len ( self . ports ) } ports but { len ( ports ) } were given.\" ) nil_params : Params = {} if self . params : nil_params = { k : v for k , v in self . params . items () if v is None } if nil_params and params is None : raise KeyError ( f \"Must supply non default parameters. \" f \"Needed { list ( nil_params . keys ()) } \" ) if nil_params and params and ( params . keys () != nil_params . keys ()): raise KeyError ( f \"Parameters do not match with default params. \" f \"Needed { list ( nil_params . keys ()) } but got { list ( params . keys ()) } \" ) user_params = params if params else {} return Component ( ports , { ** nil_params , ** user_params }, name = self . name , letter = self . letter )","title":"inst()"},{"location":"api/#nimphel.circuit.Circuit","text":"Class to handle the state of the circuit. Attributes: Name Type Description instances Dict to track component ids. components List [ Component ] List of component instances. subcircuits Dict [ str , Subckt ] Dict to track subcircuit definitions. nets int Counter to keep track of the nets. exporter int Exporter used to create the netlist. Source code in nimphel/circuit.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 class Circuit : \"\"\"Class to handle the state of the circuit. Attributes: instances: Dict to track component ids. components: List of component instances. subcircuits: Dict to track subcircuit definitions. nets: Counter to keep track of the nets. exporter: Exporter used to create the netlist. \"\"\" def __init__ ( self ): self . instances = defaultdict ( int ) self . components : List [ Component ] = [] self . subcircuits : Dict [ str , Subckt ] = {} self . nets : int = 0 def add ( self , component : Union [ np . ndarray , Tuple [ Component ], List [ Component ], Component ], ): \"\"\"Add a component instance to the circuit. Args: component: Component or list of component instances. \"\"\" if isinstance ( component , np . ndarray ): self . components += np . ravel ( component ) . tolist () elif isinstance ( component , ( tuple , list )): self . components += component else : self . components . append ( component ) def __contains__ ( self , inst : Union [ Component , Subckt ]) -> bool : \"\"\"Checks if a component or subcircuit is present inside the circuit. Args: inst: Component or subcircuit to check. Returns: True if the instance is inside the circuit. \"\"\" if isinstance ( inst , Component ): return inst in self . components return inst in self . subcircuits or any ( inst . name == c . name for c in self . components ) def into_subckt ( self , name : str , ports : Ports , params : Optional [ Params ] = None ) -> Subckt : \"\"\"Convert the state into a subcircuit. Args: name: Name of the subcircuit. ports: Ports of the subcircuit. params: Parameters of the subcircuit. Returns: Subcircuit Todo: * This subckt will register itself to the global netlist. Make this optional or prevent it from happening? \"\"\" subckt = Subckt ( name , ports , params if params else {}) subckt . add ( self . components ) return subckt def export ( self , exporter : Exporter ) -> str : \"\"\"Export the current circuit. Args: exporter: Exporter class to use. Returns: The formated circuit as a string. \"\"\" subckts = \" \\n \" . join ( map ( exporter . fmt_subckt , self . subcircuits . values ())) components = \" \\n \" . join ( map ( exporter . fmt_component , self . components )) return f \" { subckts } \\n { components } \\n \" def export_to_file ( self , outfile : Union [ str , bytes , PathLike ], exporter : Exporter ): \"\"\"Export the netlist directly to a file. Args: outfile: Path to the file. \"\"\" with open ( outfile , \"w+\" ) as file : file . write ( self . export ( exporter )) def to_dict ( self ) -> Dict [ str , Any ]: \"\"\"Export a circuit to a dict\"\"\" return { \"instances\" : dict ( self . instances ), \"components\" : [ c . to_dict () for c in self . components ], \"subcircuits\" : { k : v . to_dict () for k , v in self . subcircuits . items ()}, \"nets\" : self . nets , } def to_json ( self ) -> str : \"\"\"Returns the string representation of the component.\"\"\" return json . dumps ( self . to_dict ()) @classmethod def from_json ( cls , json_str : str ) -> Circuit : \"\"\" \"\"\" data = json . loads ( json_str ) circuit = cls () circuit . instances = defaultdict ( int , data . get ( \"instances\" , {})) def create ( sub_cls : type , data : dict [ str , Any ]): \"\"\"Wrapper to call from_json on both Component and Subcircuit.\"\"\" return sub_cls . from_json ( json . dumps ( data )) circuit . components = [ create ( Component , c ) for c in data . get ( \"components\" )] circuit . subcircuits = { name : create ( Subckt , c ) for name , c in data . get ( \"subcircuits\" ) . items () } circuit . nets = data . get ( \"nets\" , 0 ) return circuit def to_graph ( self , comps : Optional [ List [ Component ]] = None , root : Optional [ str ] = None , * , name : str = \"circuit\" , ) -> nx . Graph : \"\"\"Create a graph with the instances in the circuit. This functions adds connections between the root and every component instance. If the component instance is a subcircuit, this function gets called again with the subcircuit as the root node. The weight between the connections represents the number of components that are inside a circuit or subcircuit, that is, the dependencies. The dependencies are normalized for just one subcircuit. To know the real number of instances in the total circuit, see ``count_instances``. By default the root of the circuit is called `circuit`. This root name can be changed with the `name` argument. Args: comps: List of component instances. root: Name of the node that serves as the root. name: Name of the global root. Defaults to 'circuit'. Returns: The generated graph with all components, subcircuits and the circuit. \"\"\" circuit_graph , visited = nx . Graph (), set () if root is None : circuit_graph . add_node ( name , color = \"yellow\" ) root = name components = comps if comps else self . components instances = Counter ([ c . name for c in components ]) for comp_name , count in instances . items (): if name in visited : continue subckt = self . subcircuits . get ( comp_name , None ) if subckt : circuit_graph . add_node ( subckt . name , color = \"orange\" ) circuit_graph . add_edge ( root , subckt . name , weight = count ) graph = self . to_graph ( subckt . components , root = subckt . name ) circuit_graph = nx . compose ( circuit_graph , graph ) else : # Simple component circuit_graph . add_node ( comp_name , color = \"red\" ) circuit_graph . add_edge ( root , comp_name , weight = count ) visited . add ( comp_name ) return circuit_graph def count_instances ( self , root = \"circuit\" ) -> Dict [ str , int ]: \"\"\"Count the number of instances in the circuit. This functions calculates the total number of instances by traversing the graph generated with the method ``to_graph``. Args: root: Name of the root node. Has to match the one passed to 'to_graph'. Returns: A dict containing the instance name and the respective global count. \"\"\" instances : Dict [ str , int ] = {} graph = self . to_graph () for node in map ( lambda n : n [ 0 ], graph . nodes ( data = True )): is_subckt = node in self . subcircuits if node == root : continue valid_paths = [] for path in nx . all_simple_paths ( graph , source = root , target = node ): route , edges = [], list ( nx . utils . pairwise ( path )) for ( start , end ) in edges : if start == root : route . append (( start , end )) continue if is_subckt : if not end in self . subcircuits : route . clear () break route . append (( start , end )) else : if not start in self . subcircuits and end in self . subcircuits : route . clear () break route . append (( start , end )) valid_paths . append ( route ) count = 0 for path in filter ( bool , valid_paths ): count_path = 1 for start , end in path : data = graph . get_edge_data ( start , end ) count_path *= data [ \"weight\" ] count += count_path instances [ node ] = count return instances","title":"Circuit"},{"location":"api/#nimphel.circuit.Circuit.__contains__","text":"Checks if a component or subcircuit is present inside the circuit. Parameters: Name Type Description Default inst Union [ Component , Subckt ] Component or subcircuit to check. required Returns: Type Description bool True if the instance is inside the circuit. Source code in nimphel/circuit.py 53 54 55 56 57 58 59 60 61 62 63 64 65 66 def __contains__ ( self , inst : Union [ Component , Subckt ]) -> bool : \"\"\"Checks if a component or subcircuit is present inside the circuit. Args: inst: Component or subcircuit to check. Returns: True if the instance is inside the circuit. \"\"\" if isinstance ( inst , Component ): return inst in self . components return inst in self . subcircuits or any ( inst . name == c . name for c in self . components )","title":"__contains__()"},{"location":"api/#nimphel.circuit.Circuit.add","text":"Add a component instance to the circuit. Parameters: Name Type Description Default component Union [ np . ndarray , Tuple [ Component ], List [ Component ], Component ] Component or list of component instances. required Source code in nimphel/circuit.py 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 def add ( self , component : Union [ np . ndarray , Tuple [ Component ], List [ Component ], Component ], ): \"\"\"Add a component instance to the circuit. Args: component: Component or list of component instances. \"\"\" if isinstance ( component , np . ndarray ): self . components += np . ravel ( component ) . tolist () elif isinstance ( component , ( tuple , list )): self . components += component else : self . components . append ( component )","title":"add()"},{"location":"api/#nimphel.circuit.Circuit.count_instances","text":"Count the number of instances in the circuit. This functions calculates the total number of instances by traversing the graph generated with the method to_graph . Parameters: Name Type Description Default root Name of the root node. Has to match the one passed to 'to_graph'. 'circuit' Returns: Type Description Dict [ str , int ] A dict containing the instance name and the respective global count. Source code in nimphel/circuit.py 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 def count_instances ( self , root = \"circuit\" ) -> Dict [ str , int ]: \"\"\"Count the number of instances in the circuit. This functions calculates the total number of instances by traversing the graph generated with the method ``to_graph``. Args: root: Name of the root node. Has to match the one passed to 'to_graph'. Returns: A dict containing the instance name and the respective global count. \"\"\" instances : Dict [ str , int ] = {} graph = self . to_graph () for node in map ( lambda n : n [ 0 ], graph . nodes ( data = True )): is_subckt = node in self . subcircuits if node == root : continue valid_paths = [] for path in nx . all_simple_paths ( graph , source = root , target = node ): route , edges = [], list ( nx . utils . pairwise ( path )) for ( start , end ) in edges : if start == root : route . append (( start , end )) continue if is_subckt : if not end in self . subcircuits : route . clear () break route . append (( start , end )) else : if not start in self . subcircuits and end in self . subcircuits : route . clear () break route . append (( start , end )) valid_paths . append ( route ) count = 0 for path in filter ( bool , valid_paths ): count_path = 1 for start , end in path : data = graph . get_edge_data ( start , end ) count_path *= data [ \"weight\" ] count += count_path instances [ node ] = count return instances","title":"count_instances()"},{"location":"api/#nimphel.circuit.Circuit.export","text":"Export the current circuit. Parameters: Name Type Description Default exporter Exporter Exporter class to use. required Returns: Type Description str The formated circuit as a string. Source code in nimphel/circuit.py 89 90 91 92 93 94 95 96 97 98 99 100 def export ( self , exporter : Exporter ) -> str : \"\"\"Export the current circuit. Args: exporter: Exporter class to use. Returns: The formated circuit as a string. \"\"\" subckts = \" \\n \" . join ( map ( exporter . fmt_subckt , self . subcircuits . values ())) components = \" \\n \" . join ( map ( exporter . fmt_component , self . components )) return f \" { subckts } \\n { components } \\n \"","title":"export()"},{"location":"api/#nimphel.circuit.Circuit.export_to_file","text":"Export the netlist directly to a file. Parameters: Name Type Description Default outfile Union [ str , bytes , PathLike ] Path to the file. required Source code in nimphel/circuit.py 102 103 104 105 106 107 108 109 def export_to_file ( self , outfile : Union [ str , bytes , PathLike ], exporter : Exporter ): \"\"\"Export the netlist directly to a file. Args: outfile: Path to the file. \"\"\" with open ( outfile , \"w+\" ) as file : file . write ( self . export ( exporter ))","title":"export_to_file()"},{"location":"api/#nimphel.circuit.Circuit.into_subckt","text":"Convert the state into a subcircuit. Parameters: Name Type Description Default name str Name of the subcircuit. required ports Ports Ports of the subcircuit. required params Optional [ Params ] Parameters of the subcircuit. None Returns: Type Description Subckt Subcircuit Todo This subckt will register itself to the global netlist. Make this optional or prevent it from happening? Source code in nimphel/circuit.py 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 def into_subckt ( self , name : str , ports : Ports , params : Optional [ Params ] = None ) -> Subckt : \"\"\"Convert the state into a subcircuit. Args: name: Name of the subcircuit. ports: Ports of the subcircuit. params: Parameters of the subcircuit. Returns: Subcircuit Todo: * This subckt will register itself to the global netlist. Make this optional or prevent it from happening? \"\"\" subckt = Subckt ( name , ports , params if params else {}) subckt . add ( self . components ) return subckt","title":"into_subckt()"},{"location":"api/#nimphel.circuit.Circuit.to_dict","text":"Export a circuit to a dict Source code in nimphel/circuit.py 111 112 113 114 115 116 117 118 def to_dict ( self ) -> Dict [ str , Any ]: \"\"\"Export a circuit to a dict\"\"\" return { \"instances\" : dict ( self . instances ), \"components\" : [ c . to_dict () for c in self . components ], \"subcircuits\" : { k : v . to_dict () for k , v in self . subcircuits . items ()}, \"nets\" : self . nets , }","title":"to_dict()"},{"location":"api/#nimphel.circuit.Circuit.to_graph","text":"Create a graph with the instances in the circuit. This functions adds connections between the root and every component instance. If the component instance is a subcircuit, this function gets called again with the subcircuit as the root node. The weight between the connections represents the number of components that are inside a circuit or subcircuit, that is, the dependencies. The dependencies are normalized for just one subcircuit. To know the real number of instances in the total circuit, see count_instances . By default the root of the circuit is called circuit . This root name can be changed with the name argument. Parameters: Name Type Description Default comps Optional [ List [ Component ]] List of component instances. None root Optional [ str ] Name of the node that serves as the root. None name str Name of the global root. Defaults to 'circuit'. 'circuit' Returns: Type Description nx . Graph The generated graph with all components, subcircuits and the circuit. Source code in nimphel/circuit.py 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 def to_graph ( self , comps : Optional [ List [ Component ]] = None , root : Optional [ str ] = None , * , name : str = \"circuit\" , ) -> nx . Graph : \"\"\"Create a graph with the instances in the circuit. This functions adds connections between the root and every component instance. If the component instance is a subcircuit, this function gets called again with the subcircuit as the root node. The weight between the connections represents the number of components that are inside a circuit or subcircuit, that is, the dependencies. The dependencies are normalized for just one subcircuit. To know the real number of instances in the total circuit, see ``count_instances``. By default the root of the circuit is called `circuit`. This root name can be changed with the `name` argument. Args: comps: List of component instances. root: Name of the node that serves as the root. name: Name of the global root. Defaults to 'circuit'. Returns: The generated graph with all components, subcircuits and the circuit. \"\"\" circuit_graph , visited = nx . Graph (), set () if root is None : circuit_graph . add_node ( name , color = \"yellow\" ) root = name components = comps if comps else self . components instances = Counter ([ c . name for c in components ]) for comp_name , count in instances . items (): if name in visited : continue subckt = self . subcircuits . get ( comp_name , None ) if subckt : circuit_graph . add_node ( subckt . name , color = \"orange\" ) circuit_graph . add_edge ( root , subckt . name , weight = count ) graph = self . to_graph ( subckt . components , root = subckt . name ) circuit_graph = nx . compose ( circuit_graph , graph ) else : # Simple component circuit_graph . add_node ( comp_name , color = \"red\" ) circuit_graph . add_edge ( root , comp_name , weight = count ) visited . add ( comp_name ) return circuit_graph","title":"to_graph()"},{"location":"api/#nimphel.circuit.Circuit.to_json","text":"Returns the string representation of the component. Source code in nimphel/circuit.py 120 121 122 def to_json ( self ) -> str : \"\"\"Returns the string representation of the component.\"\"\" return json . dumps ( self . to_dict ())","title":"to_json()"},{"location":"api/#nimphel.circuit.create_graph","text":"Create the plot to visualize the graph generated by a circuit. Matplotlib.pyplot needs to be imported and the function show needs to be called in order to visualize the plot. Parameters: Name Type Description Default graph nx . Graph The circuit graph to plot. required Source code in nimphel/circuit.py 240 241 242 243 244 245 246 247 248 249 250 251 252 def create_graph ( graph : nx . Graph ): \"\"\"Create the plot to visualize the graph generated by a circuit. `Matplotlib.pyplot` needs to be imported and the function `show` needs to be called in order to visualize the plot. Args: graph: The circuit graph to plot. \"\"\" pos = nx . spring_layout ( graph ) color_map = [ data [ \"color\" ] for ( name , data ) in graph . nodes ( data = True )] nx . draw_networkx ( graph , pos , with_labels = True , node_color = color_map ) labels = nx . get_edge_attributes ( graph , \"weight\" ) nx . draw_networkx_edge_labels ( graph , pos , edge_labels = labels )","title":"create_graph()"},{"location":"api/#nimphel.parsers.cast_value","text":"Cast a string to an int, or float or string. The value is casted to int. If it fails it is casted to float and if that fails, the value is returned without modification. Parameters: Name Type Description Default val str Value we want to cast required Returns: Type Description ParamValue The value casted to the type. Source code in nimphel/parsers.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 def cast_value ( val : str ) -> ParamValue : \"\"\"Cast a string to an int, or float or string. The value is casted to int. If it fails it is casted to float and if that fails, the value is returned without modification. Args: val: Value we want to cast Returns: The value casted to the type. \"\"\" for t in [ int , float ]: try : value = t ( val ) return value except ValueError : pass return val","title":"cast_value()"},{"location":"api/#nimphel.parsers.eldo_parser","text":"Parser for eldo technology files. Parameters: Name Type Description Default lib TextIO Path to the lib file. required Returns: Type Description Dict [ str , Model ] Dictionary containing the models in the file. Source code in nimphel/parsers.py 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 def eldo_parser ( lib : TextIO ) -> Dict [ str , Model ]: \"\"\"Parser for eldo technology files. Args: lib: Path to the lib file. Returns: Dictionary containing the models in the file. \"\"\" re_subckt = re . compile ( r \"\\.subckt (\\w+) .*\" ) models : Dict [ str , Model ] = {} lines = iter ([ l . strip () for l in lib . readlines ()]) line = next ( lines ) while lines : while not re_subckt . search ( line ): try : line = next ( lines ) except StopIteration : return models subckt_name = re_subckt . search ( line ) . group ( 1 ) while not line . startswith ( \"+\" ): line = next ( lines ) param_lines = [] while line . startswith ( \"+\" ): param_lines . append ( line [ 1 :] . strip ()) line = next ( lines ) params = {} parameters = \" \" . join ( param_lines ) for param in parameters [ 6 :] . split ( \" \" ): name , value = param . split ( \"=\" ) params [ name ] = cast_value ( value ) models [ subckt_name ] = Model ( subckt_name , params ) return models","title":"eldo_parser()"},{"location":"api/#nimphel.parsers.parse_model_file","text":"Parse a technology file using the given parser Parameters: Name Type Description Default file_path PathLike Path to the technology file. required parser Parser Parser to use in the file. required Returns: Type Description Dict [ str , Model ] Dictionary containing the models in the file. Source code in nimphel/parsers.py 174 175 176 177 178 179 180 181 182 183 184 def parse_model_file ( file_path : PathLike , parser : Parser ) -> Dict [ str , Model ]: \"\"\"Parse a technology file using the given parser Args: file_path: Path to the technology file. parser: Parser to use in the file. Returns: Dictionary containing the models in the file. \"\"\" with open ( file_path , \"r\" ) as f : return parser ( f )","title":"parse_model_file()"},{"location":"api/#nimphel.parsers.spectre_parser","text":"Parser for spectre technology files. Parameters: Name Type Description Default lib TextIO Path to the lib file. required Returns: Type Description Dict [ str , Model ] Dictionary containing the models in the file. Source code in nimphel/parsers.py 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 def spectre_parser ( lib : TextIO ) -> Dict [ str , Model ]: \"\"\"Parser for spectre technology files. Args: lib: Path to the lib file. Returns: Dictionary containing the models in the file. \"\"\" re_subckt = re . compile ( r \"subckt (\\w+) .*\" ) re_param = re . compile ( r \"\\+ (\\w+) = (.*)\" ) models : Dict [ str , Model ] = {} lines = iter ([ l . strip () for l in lib . readlines ()]) line = next ( lines ) while lines : while not re_subckt . search ( line ): try : line = next ( lines ) except StopIteration : return models subckt_name = re_subckt . search ( line ) . group ( 1 ) while not re_param . search ( line ): line = next ( lines ) params = {} while not re_param . search ( line ): line = next ( lines ) while re_param . search ( line ): name , value = re_param . search ( line ) . groups () params [ name ] = cast_value ( value ) line = next ( lines ) models [ subckt_name ] = Model ( subckt_name , params ) return models","title":"spectre_parser()"},{"location":"api/#nimphel.parsers.veriloga_parser","text":"Parser for verilogA files. Parameters: Name Type Description Default lib TextIO Path to the lib file. required Returns: Type Description Dict [ str , Model ] Dictionary containing the models in the file. Source code in nimphel/parsers.py 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 def veriloga_parser ( lib : TextIO ) -> Dict [ str , Model ]: \"\"\"Parser for verilogA files. Args: lib: Path to the lib file. Returns: Dictionary containing the models in the file. \"\"\" models : Dict [ str , Model ] = {} lines = iter ([ l . strip () for l in lib . readlines ()]) param_re = re . compile ( r \".*parameter \\w+ (\\w+) = (.*);\" ) module_re = re . compile ( r \".*module (\\w+) .*;\" ) line = next ( lines ) while lines : while not module_re . search ( line ): try : line = next ( lines ) except StopIteration : return models module_name = module_re . search ( line ) . group ( 1 ) params = {} while not line . startswith ( \"analog begin\" ): line = next ( lines ) if param_re . search ( line ): name , value = param_re . search ( line ) . groups () params [ name ] = cast_value ( value . replace ( '\"' , \"\" )) models [ module_name ] = Model ( module_name , params ) return models","title":"veriloga_parser()"},{"location":"api/#nimphel.parsers.yaml_parser","text":"Parser for YAML files. Parameters: Name Type Description Default lib str Path to the lib file. required Returns: Type Description Dict [ str , Model ] Dictionary containing the models in the file. Source code in nimphel/parsers.py 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 def yaml_parser ( lib : str ) -> Dict [ str , Model ]: \"\"\"Parser for YAML files. Args: lib: Path to the lib file. Returns: Dictionary containing the models in the file. \"\"\" models : Dict [ str , Model ] = {} for config in yaml . load_all ( lib , Loader = yaml . Loader ): if config [ \"params\" ] . get ( \"from\" , False ): name = config [ \"params\" ][ \"from\" ] new_vals = { k : v for k , v in config . items () if k != \"from\" } params = { ** models [ name ] . params , ** new_vals } params = { k : v for k , v in params . items () if v } models [ config [ \"name\" ]] = Model ( name , params ) else : models [ config [ \"name\" ]] = Model ( ** config ) return models","title":"yaml_parser()"},{"location":"api/#nimphel.exporters.Exporter","text":"Interface for a Exporter. An exporter needs to implement functions to format a component instance, a subcircuit and a net. Source code in nimphel/exporters.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 class Exporter : \"\"\"Interface for a Exporter. An exporter needs to implement functions to format a component instance, a subcircuit and a net. \"\"\" def fmt_component ( self , comp ) -> str : \"\"\"Format a component instance.\"\"\" raise NotImplementedError def fmt_subckt ( self , subckt ) -> str : \"\"\"Format a subcircuit definition.\"\"\" raise NotImplementedError def fmt_net ( self , net ) -> str : \"\"\"Format a net.\"\"\" raise NotImplementedError","title":"Exporter"},{"location":"api/#nimphel.exporters.Exporter.fmt_component","text":"Format a component instance. Source code in nimphel/exporters.py 19 20 21 def fmt_component ( self , comp ) -> str : \"\"\"Format a component instance.\"\"\" raise NotImplementedError","title":"fmt_component()"},{"location":"api/#nimphel.exporters.Exporter.fmt_net","text":"Format a net. Source code in nimphel/exporters.py 27 28 29 def fmt_net ( self , net ) -> str : \"\"\"Format a net.\"\"\" raise NotImplementedError","title":"fmt_net()"},{"location":"api/#nimphel.exporters.Exporter.fmt_subckt","text":"Format a subcircuit definition. Source code in nimphel/exporters.py 23 24 25 def fmt_subckt ( self , subckt ) -> str : \"\"\"Format a subcircuit definition.\"\"\" raise NotImplementedError","title":"fmt_subckt()"},{"location":"api/#nimphel.exporters.SpectreExporter","text":"Bases: Exporter Exporter implementation for Spectre Source code in nimphel/exporters.py 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 class SpectreExporter ( Exporter ): \"\"\"Exporter implementation for Spectre\"\"\" def __fmt_value ( self , value ): if isinstance ( value , list ): return f '[ { \" \" . join ( map ( str , value )) } ]' if isinstance ( value , ( float , int )): return f \" { value : .2F } \" return f '\" { value } \"' def fmt_component ( self , comp ) -> str : if hasattr ( comp , \"fmt\" ): return comp . fmt () ports = \" \" . join ( map ( self . fmt_net , comp . ports )) params_not_nil = { k : v for k , v in comp . params . items () if v } params = \" \" . join ( [ f \" { k } = { self . __fmt_value ( v ) } \" for k , v in params_not_nil . items ()] ) return f \" { comp . letter }{ comp . num_id } ( { ports } ) { comp . name } { params } \" def fmt_subckt ( self , subckt ) -> str : comps = \" \\n \" . join ( map ( self . fmt_component , subckt . components )) ports = \" \" . join ( map ( self . fmt_net , subckt . ports )) nil_params = [ f \" { k } \" for k , v in subckt . params . items () if not v ] val_params = [ f \" { k } = { v } \" for k , v in subckt . params . items () if v ] if val_params or nil_params : params = f \"parameters { ' ' . join ( nil_params + val_params ) } \\n \" else : params = \"\" return ( f \"subckt { subckt . name } { ports } \\n \" f \" { params } \" f \" { comps } \\n \" f \"ends { subckt . name } \\n \" ) def fmt_net ( self , net : Union [ str , int ]) -> str : if isinstance ( net , int ): return f \"net { net } \" return net","title":"SpectreExporter"},{"location":"api/#nimphel.exporters.models_to_yaml","text":"models: out_path: Source code in nimphel/exporters.py 75 76 77 78 79 80 81 82 83 def models_to_yaml ( models : Dict [ str , Model ], out_path : PathLike ): \"\"\" Args: models: out_path: \"\"\" data = [{ \"name\" : name , \"params\" : model . params } for name , model in models . items ()] with open ( out_path , \"w+\" ) as f : f . write ( yaml . dump_all ( data , Dumper = yaml . Dumper ))","title":"models_to_yaml()"},{"location":"exporters/","text":"Exporters Exporters allow the generation of a text file based on a series of elements. Their main use is to generate a SPICE netlist from a Circuit. There are however, exporters to save models to files to be loaded later on. Exporting to a netlist Any circuit can be exported to a netlist by using the export method. This method only requires the exporter class. Exporting a circuit from nimphel.exporters import Exporter netlist . export ( Exporter ) To export directly to a file, use the method export_to_file . Exporting a circuit to a file netlist . export_to_file ( \"/path/to/file\" , Exporter ) Custom Exporter As of today only the following exporters are implemented: SpectreExporter . A custom exporter can be created by implementing the following interface. Info When writing an exporter, it is advised to check if a component implements the fmt() method and use it instead. class Exporter : \"\"\"Interface for a Exporter.\"\"\" def fmt_component ( self , component ) -> str : \"\"\"Format a component instance.\"\"\" raise NotImplementedError def fmt_subckt ( self , subcircuit ) -> str : \"\"\"Format a subcircuit definition.\"\"\" raise NotImplementedError def fmt_net ( self , net ) -> str : \"\"\"Format a net.\"\"\" raise NotImplementedError Exporting models Models can be exported to a YAML file by using the function models_to_yaml . These models can be read back by using the yaml parser (see parsers ). models_to_yaml ( models , \"/path/to/models.yml\" ) Info In the future, custom exporters will be added to resemble the functionality of the parsers.","title":"Exporters"},{"location":"exporters/#exporters","text":"Exporters allow the generation of a text file based on a series of elements. Their main use is to generate a SPICE netlist from a Circuit. There are however, exporters to save models to files to be loaded later on.","title":"Exporters"},{"location":"exporters/#exporting-to-a-netlist","text":"Any circuit can be exported to a netlist by using the export method. This method only requires the exporter class. Exporting a circuit from nimphel.exporters import Exporter netlist . export ( Exporter ) To export directly to a file, use the method export_to_file . Exporting a circuit to a file netlist . export_to_file ( \"/path/to/file\" , Exporter )","title":"Exporting to a netlist"},{"location":"exporters/#custom-exporter","text":"As of today only the following exporters are implemented: SpectreExporter . A custom exporter can be created by implementing the following interface. Info When writing an exporter, it is advised to check if a component implements the fmt() method and use it instead. class Exporter : \"\"\"Interface for a Exporter.\"\"\" def fmt_component ( self , component ) -> str : \"\"\"Format a component instance.\"\"\" raise NotImplementedError def fmt_subckt ( self , subcircuit ) -> str : \"\"\"Format a subcircuit definition.\"\"\" raise NotImplementedError def fmt_net ( self , net ) -> str : \"\"\"Format a net.\"\"\" raise NotImplementedError","title":"Custom Exporter"},{"location":"exporters/#exporting-models","text":"Models can be exported to a YAML file by using the function models_to_yaml . These models can be read back by using the yaml parser (see parsers ). models_to_yaml ( models , \"/path/to/models.yml\" ) Info In the future, custom exporters will be added to resemble the functionality of the parsers.","title":"Exporting models"},{"location":"manipulation/","text":"Manipulation The manipulation of components is one of the key features of nimphel. Nimphel makes use of the basic mathematical operators to manipulate components. Chain Chained components start in the component input and generate a chain where the input of a new component is the output of the previous one. The operator * is used to chain components. The ports of chained components follow this behaviour: (in, out) -> (out, net()) -> ... (net(), net()) Example of chained components Res = R ([ GND , net ()]) netlist . add ( Res * 3 ) # Will produce 3 resistances with the ports: # (GND, 1), (1, 2), (2, 3) A component can also be chained by using a tuple containing the fields (num components, last net name) as follows: Chained components with named output Res = R ([ GND , net ()]) netlist . add ( Res * ( 3 , \"OUT\" )) # Will produce 3 resistances with the ports: # (GND, 1), (1, 2), (2, \"OUT\") Parallel Components in parallel share the same input and output. The operator | is used to create components in parallel. The ports of components in parallel follow this behaviour: (in, out) -> (in, out) -> ... (in, out) Example of components in parallel Res = R ([ GND , net ()]) netlist . add ( Res | 3 ) # Will produce 3 resistances with the ports # (GND, 1), (GND, 1), (GND, 1) Self loop A self loop creates a copy of the component and reverses the order of the ports, that is, input is connected to output and viceversa. The operator ~ is used to create self loops. The ports of components in self loop this behaviour: (in, out) -> (out, in) Example of self looped components Res = R ([ GND , net ()]) netlist . add ( ~ Res ) # Will produce 2 resistances with the ports # (GND, 1), (1, GND) Fan out Components in fan out share the same input but have a different output port each. The operator ^ is used to create fan outs. The ports of components in fan out follow this behaviour: (in, out) -> (in, net()) -> ... (in, net()) Example of components in fan out Res = R ([ GND , net ()]) netlist . add ( Res ^ 3 ) # Will produce 3 resistances with the ports # (GND, 1), (GND, 2), (GND, 3) Direct Components that are directed, have the same output but have a different input each. It's behaviour is the opposite of fan out . The operator & is used to create self loops. The ports of components in fan out follow this behaviour: (in, out) -> (net(), out) -> ... (net(), out) Example of directed components. Res = R ([ GND , net ()]) netlist . add ( Res & 3 ) # Will produce 3 resistances with the ports # (2, 1), (3, 1), (4, 1) Complex manipulation For components that are more complex, there are methods to defined the connections. The ports for chains are defined using masks, that is, a tuple whose non null positions mark the number of ports to chain. A chain will not work in this case with a Mosfet since the chain will be done, with the ports \"out\" and \"GND\". We need to define the chain using the first and second port. m = Mosfet ([ \"out\" , \"in\" , GND , GND ], name = \"nmos\" ) m . chain (( 1 , 1 , 0 , 0 ), 3 ) m . parallel (( 1 , 1 , 0 , 0 ), 3 ) m . self_loop (( 1 , 1 , 0 , 0 ), 3 ) m . fanout (( 1 , 1 , 0 , 0 ), 3 ) m . direct (( 1 , 1 , 0 , 0 ), 3 ) Getting ports Setting ports 1D and 2D Arrays Components that follow a 1D or 2D configuration can be instanciated quickly by usig the function make_array . This function takes 3 arguments. Tuple containing the 1D or 2D dimensions of the array. The coordinates are given as (Y, X) The component instance that will be used to fill the array. If provided, a function that will received the coordinates of the component and will return the ports of that component. Generating a 1D array of resistances def ports_res ( p ): return [ f 'X_ { c [ 0 ] } ' , GND ] arr = make_array (( 5 , ), R ([ \"\" , \"\" ]), ports_fn = ports_res ) netlist . add ( arr ) Generating a 2D array of resistances def ports_res ( p ): x , y = p return [ f \"Y_ { y } \" , f \"X_ { x } \" ] arr = array (( 3 , 5 ), R ([ \"\" , \"\" ]), ports_fn = ports_res ) netlist . add ( arr ) The array is created by using numpy, so we have access to numpy tools. Printing an array of components. for y , x in np . ndindex ( m . shape ): print ( arr [ y , x ])","title":"Manipulation"},{"location":"manipulation/#manipulation","text":"The manipulation of components is one of the key features of nimphel. Nimphel makes use of the basic mathematical operators to manipulate components.","title":"Manipulation"},{"location":"manipulation/#chain","text":"Chained components start in the component input and generate a chain where the input of a new component is the output of the previous one. The operator * is used to chain components. The ports of chained components follow this behaviour: (in, out) -> (out, net()) -> ... (net(), net()) Example of chained components Res = R ([ GND , net ()]) netlist . add ( Res * 3 ) # Will produce 3 resistances with the ports: # (GND, 1), (1, 2), (2, 3) A component can also be chained by using a tuple containing the fields (num components, last net name) as follows: Chained components with named output Res = R ([ GND , net ()]) netlist . add ( Res * ( 3 , \"OUT\" )) # Will produce 3 resistances with the ports: # (GND, 1), (1, 2), (2, \"OUT\")","title":"Chain"},{"location":"manipulation/#parallel","text":"Components in parallel share the same input and output. The operator | is used to create components in parallel. The ports of components in parallel follow this behaviour: (in, out) -> (in, out) -> ... (in, out) Example of components in parallel Res = R ([ GND , net ()]) netlist . add ( Res | 3 ) # Will produce 3 resistances with the ports # (GND, 1), (GND, 1), (GND, 1)","title":"Parallel"},{"location":"manipulation/#self-loop","text":"A self loop creates a copy of the component and reverses the order of the ports, that is, input is connected to output and viceversa. The operator ~ is used to create self loops. The ports of components in self loop this behaviour: (in, out) -> (out, in) Example of self looped components Res = R ([ GND , net ()]) netlist . add ( ~ Res ) # Will produce 2 resistances with the ports # (GND, 1), (1, GND)","title":"Self loop"},{"location":"manipulation/#fan-out","text":"Components in fan out share the same input but have a different output port each. The operator ^ is used to create fan outs. The ports of components in fan out follow this behaviour: (in, out) -> (in, net()) -> ... (in, net()) Example of components in fan out Res = R ([ GND , net ()]) netlist . add ( Res ^ 3 ) # Will produce 3 resistances with the ports # (GND, 1), (GND, 2), (GND, 3)","title":"Fan out"},{"location":"manipulation/#direct","text":"Components that are directed, have the same output but have a different input each. It's behaviour is the opposite of fan out . The operator & is used to create self loops. The ports of components in fan out follow this behaviour: (in, out) -> (net(), out) -> ... (net(), out) Example of directed components. Res = R ([ GND , net ()]) netlist . add ( Res & 3 ) # Will produce 3 resistances with the ports # (2, 1), (3, 1), (4, 1)","title":"Direct"},{"location":"manipulation/#complex-manipulation","text":"For components that are more complex, there are methods to defined the connections. The ports for chains are defined using masks, that is, a tuple whose non null positions mark the number of ports to chain. A chain will not work in this case with a Mosfet since the chain will be done, with the ports \"out\" and \"GND\". We need to define the chain using the first and second port. m = Mosfet ([ \"out\" , \"in\" , GND , GND ], name = \"nmos\" ) m . chain (( 1 , 1 , 0 , 0 ), 3 ) m . parallel (( 1 , 1 , 0 , 0 ), 3 ) m . self_loop (( 1 , 1 , 0 , 0 ), 3 ) m . fanout (( 1 , 1 , 0 , 0 ), 3 ) m . direct (( 1 , 1 , 0 , 0 ), 3 )","title":"Complex manipulation"},{"location":"manipulation/#getting-ports","text":"","title":"Getting ports"},{"location":"manipulation/#setting-ports","text":"","title":"Setting ports"},{"location":"manipulation/#1d-and-2d-arrays","text":"Components that follow a 1D or 2D configuration can be instanciated quickly by usig the function make_array . This function takes 3 arguments. Tuple containing the 1D or 2D dimensions of the array. The coordinates are given as (Y, X) The component instance that will be used to fill the array. If provided, a function that will received the coordinates of the component and will return the ports of that component. Generating a 1D array of resistances def ports_res ( p ): return [ f 'X_ { c [ 0 ] } ' , GND ] arr = make_array (( 5 , ), R ([ \"\" , \"\" ]), ports_fn = ports_res ) netlist . add ( arr ) Generating a 2D array of resistances def ports_res ( p ): x , y = p return [ f \"Y_ { y } \" , f \"X_ { x } \" ] arr = array (( 3 , 5 ), R ([ \"\" , \"\" ]), ports_fn = ports_res ) netlist . add ( arr ) The array is created by using numpy, so we have access to numpy tools. Printing an array of components. for y , x in np . ndindex ( m . shape ): print ( arr [ y , x ])","title":"1D and 2D Arrays"},{"location":"parsers/","text":"Parsers Parsers allow the generation of models automatically from files. Nimphel comes with some parsers by default. If some technology file is not supported file it's very easy to create your custom parser. Parsing a definition file requires two things. The function parse_model_file The parser that will be used for the file. The parser has the signature def parser ( lib : TextIO ) -> Dict [ str , Model ] Loading models from a YAML file models = parse_model_file ( \"/path/to/models.yaml\" , yaml_parser ) @simple_component class NMosfet ( Component ): model = models [ 'NMOS' ] As of today the following parsers are implemented: eldo_parser , veriloga_parser , yaml_parser . Info More parsers may be added in the future. The current parsers can be used as a refernce to create a custom parser. Models in YAML The yaml_parser allows reading models from a YAML file. Each document inside the file represents a single model. A different YAML file can be created for a different technology, so that the same netlist can be created with the same code for different technologies just by changing the file. Example of a YAML configuration name : NMOS params : w : 0.135 nfing : 1 mult : 1 srcefirst : 1 ngcon : 1 mismatch : 1 lpe : 0 dnoise_mdev : 0 dmu_mdev : 0 dvt_mdev : 0 numcos : 1 numcod : 1 --- # Used to separate models name : PMOS params : from : NMOS # Use the parameters of NMOS w : 0.27 # Parameters can be updated new_val : 42 # New parameters can be added mismatch : ~ # Values can also be deleted The second document inside the YAML file shows the functionalities added to the file. Params can be copied from another defined model by using the key from . Parameters can be added, updated or even removed when referencing another model.","title":"Parsers"},{"location":"parsers/#parsers","text":"Parsers allow the generation of models automatically from files. Nimphel comes with some parsers by default. If some technology file is not supported file it's very easy to create your custom parser. Parsing a definition file requires two things. The function parse_model_file The parser that will be used for the file. The parser has the signature def parser ( lib : TextIO ) -> Dict [ str , Model ] Loading models from a YAML file models = parse_model_file ( \"/path/to/models.yaml\" , yaml_parser ) @simple_component class NMosfet ( Component ): model = models [ 'NMOS' ] As of today the following parsers are implemented: eldo_parser , veriloga_parser , yaml_parser . Info More parsers may be added in the future. The current parsers can be used as a refernce to create a custom parser.","title":"Parsers"},{"location":"parsers/#models-in-yaml","text":"The yaml_parser allows reading models from a YAML file. Each document inside the file represents a single model. A different YAML file can be created for a different technology, so that the same netlist can be created with the same code for different technologies just by changing the file. Example of a YAML configuration name : NMOS params : w : 0.135 nfing : 1 mult : 1 srcefirst : 1 ngcon : 1 mismatch : 1 lpe : 0 dnoise_mdev : 0 dmu_mdev : 0 dvt_mdev : 0 numcos : 1 numcod : 1 --- # Used to separate models name : PMOS params : from : NMOS # Use the parameters of NMOS w : 0.27 # Parameters can be updated new_val : 42 # New parameters can be added mismatch : ~ # Values can also be deleted The second document inside the YAML file shows the functionalities added to the file. Params can be copied from another defined model by using the key from . Parameters can be added, updated or even removed when referencing another model.","title":"Models in YAML"},{"location":"elements/circuit/","text":"Creating a subcircuit Example of creating an AND gate and_gate = Circuit () out_and = net () and_gate . add ( Mosfet ([ \"A\" , VDD , \"OUT\" , VDD ], name = \"pmos\" )) and_gate . add ( Mosfet ([ \"B\" , VDD , \"OUT\" , VDD ], name = \"pmos\" )) and_gate . add ( Mosfet ([ \"B\" , \"OUT\" , out_and , GND ], name = \"nmos\" )) and_gate . add ( Mosfet ([ \"A\" , out_and , GND , GND ], name = \"nmos\" )) AND_GATE = and_gate . into_subckt ( \"AND\" , [ \"A\" , \"B\" , \"OUT\" ], {}) Global circuit There is a global circuit called netlist that exists within nimphel. Dependency graph graph = netlist . to_graph () generate_graph ( graph ) Number of instances netlist . count_instances ()","title":"Circuits"},{"location":"elements/circuit/#creating-a-subcircuit","text":"Example of creating an AND gate and_gate = Circuit () out_and = net () and_gate . add ( Mosfet ([ \"A\" , VDD , \"OUT\" , VDD ], name = \"pmos\" )) and_gate . add ( Mosfet ([ \"B\" , VDD , \"OUT\" , VDD ], name = \"pmos\" )) and_gate . add ( Mosfet ([ \"B\" , \"OUT\" , out_and , GND ], name = \"nmos\" )) and_gate . add ( Mosfet ([ \"A\" , out_and , GND , GND ], name = \"nmos\" )) AND_GATE = and_gate . into_subckt ( \"AND\" , [ \"A\" , \"B\" , \"OUT\" ], {})","title":"Creating a subcircuit"},{"location":"elements/circuit/#global-circuit","text":"There is a global circuit called netlist that exists within nimphel.","title":"Global circuit"},{"location":"elements/circuit/#dependency-graph","text":"graph = netlist . to_graph () generate_graph ( graph )","title":"Dependency graph"},{"location":"elements/circuit/#number-of-instances","text":"netlist . count_instances ()","title":"Number of instances"},{"location":"elements/component/","text":"Creation of components Creation of a simple Resistance class R ( Component ): def __init__ ( self , ports , params = None ): defaults : Params = { \"R\" : 1e3 } user_params = dict ( params ) if params else {} super ( R , self ) . __init__ ( ports , { ** defaults , ** user_params }, name = \"Res\" ) def fmt ( self ) -> str : def fmt_net ( net ): return f \"net { net } \" if isinstance ( net , int ) else net ports = \" \" . join ( map ( fmt_net , self . ports )) return f 'R { self . num_id } ( { ports } ) R { self . params [ \"R\" ] } ' A component may implement an additional method called fmt() . This method accepts no argument and should return the string representation of the component. Wrapper for simple components The process of creating multiple simple components can be tedious. The wrapper @simple_component allows to create components similarly to a dataclass. @simple_component class C ( Component ): name : \"Capacitor\" letter : \"C\" defaults : Params = { \"C\" : 1e3 , \"T\" : None } Component models A model allows to reuse a component name and a set of parameters across multiple definitions. Creation of a NMOS model NMOS = Model ( name = \"nmosfet\" , params = { \"w\" : 0.135 , ... }, ) @simple_component class NMosfet ( Component ): model = NMOS class NMosfet ( Component ): def __init__ ( self , ports , params = None , name = None ): parameters = params if params else {} super ( Mosfet , self ) . __init__ ( ports , parameters , model = NMOS , name = name ) To see more about generating and storing models, please see parsers and exporters Serialization and deserialization Components can be serialized to a dict by using the to_dict method. To serialize to JSON, use the to_json method. Example of serializing and deserialization mosfet = NMosfet ([ \"in\" , \"out\" , GND , VDD ]) data = mosfet . to_dict () assert mosfet == NMosfet . from_dict ( data ) json_str = mosfet . to_json () assert mosfet == NMosfet . from_json ( json_str )","title":"Components"},{"location":"elements/component/#creation-of-components","text":"Creation of a simple Resistance class R ( Component ): def __init__ ( self , ports , params = None ): defaults : Params = { \"R\" : 1e3 } user_params = dict ( params ) if params else {} super ( R , self ) . __init__ ( ports , { ** defaults , ** user_params }, name = \"Res\" ) def fmt ( self ) -> str : def fmt_net ( net ): return f \"net { net } \" if isinstance ( net , int ) else net ports = \" \" . join ( map ( fmt_net , self . ports )) return f 'R { self . num_id } ( { ports } ) R { self . params [ \"R\" ] } ' A component may implement an additional method called fmt() . This method accepts no argument and should return the string representation of the component.","title":"Creation of components"},{"location":"elements/component/#wrapper-for-simple-components","text":"The process of creating multiple simple components can be tedious. The wrapper @simple_component allows to create components similarly to a dataclass. @simple_component class C ( Component ): name : \"Capacitor\" letter : \"C\" defaults : Params = { \"C\" : 1e3 , \"T\" : None }","title":"Wrapper for simple components"},{"location":"elements/component/#component-models","text":"A model allows to reuse a component name and a set of parameters across multiple definitions. Creation of a NMOS model NMOS = Model ( name = \"nmosfet\" , params = { \"w\" : 0.135 , ... }, ) @simple_component class NMosfet ( Component ): model = NMOS class NMosfet ( Component ): def __init__ ( self , ports , params = None , name = None ): parameters = params if params else {} super ( Mosfet , self ) . __init__ ( ports , parameters , model = NMOS , name = name ) To see more about generating and storing models, please see parsers and exporters","title":"Component models"},{"location":"elements/component/#serialization-and-deserialization","text":"Components can be serialized to a dict by using the to_dict method. To serialize to JSON, use the to_json method. Example of serializing and deserialization mosfet = NMosfet ([ \"in\" , \"out\" , GND , VDD ]) data = mosfet . to_dict () assert mosfet == NMosfet . from_dict ( data ) json_str = mosfet . to_json () assert mosfet == NMosfet . from_json ( json_str )","title":"Serialization and deserialization"},{"location":"elements/subcircuit/","text":"Creating a subcircuit Example of creating an inverter INV = Subckt ( \"INV\" , [ \"in\" , \"out\" ], {}) INV . add ( Mosfet ([ \"out\" , \"in\" , GND , GND ], name = \"nmos\" )) INV . add ( Mosfet ([ \"out\" , \"in\" , VDD , VDD ], name = \"pmos\" )) INV . fix () # Prevents the subcircuit of adding more components Instanciating a subcircuit A subcircuit can be instanciated by usig the 'inst()' method. This method takes the same arguments as Component . Instanciating an inverter inv = INV . inst ([ \"input\" , net ()], {})","title":"Subcircuits"},{"location":"elements/subcircuit/#creating-a-subcircuit","text":"Example of creating an inverter INV = Subckt ( \"INV\" , [ \"in\" , \"out\" ], {}) INV . add ( Mosfet ([ \"out\" , \"in\" , GND , GND ], name = \"nmos\" )) INV . add ( Mosfet ([ \"out\" , \"in\" , VDD , VDD ], name = \"pmos\" )) INV . fix () # Prevents the subcircuit of adding more components","title":"Creating a subcircuit"},{"location":"elements/subcircuit/#instanciating-a-subcircuit","text":"A subcircuit can be instanciated by usig the 'inst()' method. This method takes the same arguments as Component . Instanciating an inverter inv = INV . inst ([ \"input\" , net ()], {})","title":"Instanciating a subcircuit"}]}