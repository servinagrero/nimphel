{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Installation Note The project will be available on PyPi shortly. Nimphel can be installed by running one of the following commands. $ pip install . $ poetry install","title":"Introduction"},{"location":"#installation","text":"Note The project will be available on PyPi shortly. Nimphel can be installed by running one of the following commands. $ pip install . $ poetry install","title":"Installation"},{"location":"exporting/","text":"Exporting to a netlist Any circuit can be exported to a netlist. Exporting a circuit from nimphel.exporters import Exporter netlist . export ( Exporter ) To export directly to a file, use the method export_to_file() . Exporting a circuit to a file netlist . export_to_file ( \"/path/to/file\" ) Custom Exporter A custom exporter can be created by implementing the following interface. Info When writing an exporter, it is advised to check if a component implements the fmt() method and use it instead to format the component. class Exporter : \"\"\"Interface for a Exporter.\"\"\" def fmt_component ( self , component ) -> str : \"\"\"Format a component instance.\"\"\" raise NotImplementedError def fmt_subckt ( self , subcircuit ) -> str : \"\"\"Format a subcircuit definition.\"\"\" raise NotImplementedError def fmt_net ( self , net ) -> str : \"\"\"Format a net.\"\"\" raise NotImplementedError","title":"Exporting"},{"location":"exporting/#exporting-to-a-netlist","text":"Any circuit can be exported to a netlist. Exporting a circuit from nimphel.exporters import Exporter netlist . export ( Exporter ) To export directly to a file, use the method export_to_file() . Exporting a circuit to a file netlist . export_to_file ( \"/path/to/file\" )","title":"Exporting to a netlist"},{"location":"exporting/#custom-exporter","text":"A custom exporter can be created by implementing the following interface. Info When writing an exporter, it is advised to check if a component implements the fmt() method and use it instead to format the component. class Exporter : \"\"\"Interface for a Exporter.\"\"\" def fmt_component ( self , component ) -> str : \"\"\"Format a component instance.\"\"\" raise NotImplementedError def fmt_subckt ( self , subcircuit ) -> str : \"\"\"Format a subcircuit definition.\"\"\" raise NotImplementedError def fmt_net ( self , net ) -> str : \"\"\"Format a net.\"\"\" raise NotImplementedError","title":"Custom Exporter"},{"location":"manipulation/","text":"Manipulation The manipulation of components is one of the key features of nimphel. Nimphel makes use of the basic mathematical operators to manipulate components. Chain Chained components start in the component input and generate a chain where the input of a new component is the output of the previous one. The operator * is used to chain components. The ports of chained components follow this behaviour: (in, out) -> (out, net()) -> ... (net(), net()) Example of chained components Res = R ([ GND , net ()]) netlist . add ( Res * 3 ) # Will produce 3 resistances with the ports: # (GND, 1), (1, 2), (2, 3) Parallel Components in parallel share the same input and output. The operator | is used to create components in parallel. The ports of components in parallel follow this behaviour: (in, out) -> (in, out) -> ... (in, out) Example of components in parallel Res = R ([ GND , net ()]) netlist . add ( Res | 3 ) # Will produce 3 resistances with the ports # (GND, 1), (GND, 1), (GND, 1) Self loop A self loop creates a copy of the component and reverses the order of the ports, that is, input is connected to output and viceversa. The operator ~ is used to create self loops. The ports of components in parallel follow this behaviour: Example of self looped components ( in , out ) -> ( out , in ) Res = R ([ GND , net ()]) netlist . add ( ~ Res ) # Will produce 2 resistances with the ports # (GND, 1), (1, GND) Fan out Components in fan out share the same input but have a different output port each. The operator ^ is used to create fan outs. Example of components in fan out Res = R ([ GND , net ()]) netlist . add ( Res ^ 3 ) # Will produce 3 resistances with the ports # (GND, 1), (GND, 2), (GND, 3) Direct Components that are directed, have the same output but have a different input each. It's behaviour is the opposite of fan out . The operator & is used to create self loops. Example of directed components. Res = R ([ GND , net ()]) netlist . add ( Res & 3 ) # Will produce 3 resistances with the ports # (2, 1), (3, 1), (4, 1) Complex manipulation For components that are more complex, there are methods to defined the connections. The ports for chains are defined using masks, that is, a tuple whose non null positions mark the number of ports to chain. A chain will not work in this case with a Mosfet since the chain will be done, with the ports \"out\" and \"GND\". We need to define the chain using the first and second port. m = Mosfet ([ \"out\" , \"in\" , GND , GND ], name = \"nmos\" ) m . chain (( 1 , 1 , 0 , 0 ), 3 ) m . parallel (( 1 , 1 , 0 , 0 ), 3 ) m . self_loop (( 1 , 1 , 0 , 0 ), 3 ) m . fanout (( 1 , 1 , 0 , 0 ), 3 ) m . direct (( 1 , 1 , 0 , 0 ), 3 ) Getting ports Setting ports 1D and 2D Arrays Components that follow a 1D or 2D configuration can be instanciated quickly by usig the function array . This function takes 3 arguments. Tuple containing the 1D or 2D dimensions of the array. The coordinates are given as (Y, X) The component instance that will be used to fill the array. If provided, a function that will received the coordinates of the component and will return the ports of that component. Generating a 1D array of resistances arr = array (( 5 , ), R ([ \"\" , \"\" ]), ports_fn = lambda c : [ f 'X_ { c [ 0 ] } ' ]) netlist . add ( m ) Generating a 2D array of resistances def ports_res ( p ): x , y = p return [ f \"Y_ { y } \" , f \"X_ { x } \" ] arr = array (( 3 , 5 ), R ([ \"\" , \"\" ]), ports_fn = ports_res ) netlist . add ( m ) The array is created by using numpy, so we have access to numpy tools. Printing an array of components. for y , x in np . ndindex ( m . shape ): print ( m [ y , x ])","title":"Manipulation"},{"location":"manipulation/#manipulation","text":"The manipulation of components is one of the key features of nimphel. Nimphel makes use of the basic mathematical operators to manipulate components.","title":"Manipulation"},{"location":"manipulation/#chain","text":"Chained components start in the component input and generate a chain where the input of a new component is the output of the previous one. The operator * is used to chain components. The ports of chained components follow this behaviour: (in, out) -> (out, net()) -> ... (net(), net()) Example of chained components Res = R ([ GND , net ()]) netlist . add ( Res * 3 ) # Will produce 3 resistances with the ports: # (GND, 1), (1, 2), (2, 3)","title":"Chain"},{"location":"manipulation/#parallel","text":"Components in parallel share the same input and output. The operator | is used to create components in parallel. The ports of components in parallel follow this behaviour: (in, out) -> (in, out) -> ... (in, out) Example of components in parallel Res = R ([ GND , net ()]) netlist . add ( Res | 3 ) # Will produce 3 resistances with the ports # (GND, 1), (GND, 1), (GND, 1)","title":"Parallel"},{"location":"manipulation/#self-loop","text":"A self loop creates a copy of the component and reverses the order of the ports, that is, input is connected to output and viceversa. The operator ~ is used to create self loops. The ports of components in parallel follow this behaviour: Example of self looped components ( in , out ) -> ( out , in ) Res = R ([ GND , net ()]) netlist . add ( ~ Res ) # Will produce 2 resistances with the ports # (GND, 1), (1, GND)","title":"Self loop"},{"location":"manipulation/#fan-out","text":"Components in fan out share the same input but have a different output port each. The operator ^ is used to create fan outs. Example of components in fan out Res = R ([ GND , net ()]) netlist . add ( Res ^ 3 ) # Will produce 3 resistances with the ports # (GND, 1), (GND, 2), (GND, 3)","title":"Fan out"},{"location":"manipulation/#direct","text":"Components that are directed, have the same output but have a different input each. It's behaviour is the opposite of fan out . The operator & is used to create self loops. Example of directed components. Res = R ([ GND , net ()]) netlist . add ( Res & 3 ) # Will produce 3 resistances with the ports # (2, 1), (3, 1), (4, 1)","title":"Direct"},{"location":"manipulation/#complex-manipulation","text":"For components that are more complex, there are methods to defined the connections. The ports for chains are defined using masks, that is, a tuple whose non null positions mark the number of ports to chain. A chain will not work in this case with a Mosfet since the chain will be done, with the ports \"out\" and \"GND\". We need to define the chain using the first and second port. m = Mosfet ([ \"out\" , \"in\" , GND , GND ], name = \"nmos\" ) m . chain (( 1 , 1 , 0 , 0 ), 3 ) m . parallel (( 1 , 1 , 0 , 0 ), 3 ) m . self_loop (( 1 , 1 , 0 , 0 ), 3 ) m . fanout (( 1 , 1 , 0 , 0 ), 3 ) m . direct (( 1 , 1 , 0 , 0 ), 3 )","title":"Complex manipulation"},{"location":"manipulation/#getting-ports","text":"","title":"Getting ports"},{"location":"manipulation/#setting-ports","text":"","title":"Setting ports"},{"location":"manipulation/#1d-and-2d-arrays","text":"Components that follow a 1D or 2D configuration can be instanciated quickly by usig the function array . This function takes 3 arguments. Tuple containing the 1D or 2D dimensions of the array. The coordinates are given as (Y, X) The component instance that will be used to fill the array. If provided, a function that will received the coordinates of the component and will return the ports of that component. Generating a 1D array of resistances arr = array (( 5 , ), R ([ \"\" , \"\" ]), ports_fn = lambda c : [ f 'X_ { c [ 0 ] } ' ]) netlist . add ( m ) Generating a 2D array of resistances def ports_res ( p ): x , y = p return [ f \"Y_ { y } \" , f \"X_ { x } \" ] arr = array (( 3 , 5 ), R ([ \"\" , \"\" ]), ports_fn = ports_res ) netlist . add ( m ) The array is created by using numpy, so we have access to numpy tools. Printing an array of components. for y , x in np . ndindex ( m . shape ): print ( m [ y , x ])","title":"1D and 2D Arrays"},{"location":"elements/circuit/","text":"Creating a subcircuit Example of creating an AND gate and_gate = Circuit () out_and = net () and_gate . add ( Mosfet ([ \"A\" , VDD , \"OUT\" , VDD ], name = \"pmos\" )) and_gate . add ( Mosfet ([ \"B\" , VDD , \"OUT\" , VDD ], name = \"pmos\" )) and_gate . add ( Mosfet ([ \"B\" , \"OUT\" , out_and , GND ], name = \"nmos\" )) and_gate . add ( Mosfet ([ \"A\" , out_and , GND , GND ], name = \"nmos\" )) AND_GATE = and_gate . into_subckt ( \"AND\" , [ \"A\" , \"B\" , \"OUT\" ], {}) Global circuit There is a global circuit called netlist that exists within nimphel. Dependency graph graph = netlist . to_graph () generate_graph ( graph ) Number of instances netlist . coutn_instances ()","title":"Circuits"},{"location":"elements/circuit/#creating-a-subcircuit","text":"Example of creating an AND gate and_gate = Circuit () out_and = net () and_gate . add ( Mosfet ([ \"A\" , VDD , \"OUT\" , VDD ], name = \"pmos\" )) and_gate . add ( Mosfet ([ \"B\" , VDD , \"OUT\" , VDD ], name = \"pmos\" )) and_gate . add ( Mosfet ([ \"B\" , \"OUT\" , out_and , GND ], name = \"nmos\" )) and_gate . add ( Mosfet ([ \"A\" , out_and , GND , GND ], name = \"nmos\" )) AND_GATE = and_gate . into_subckt ( \"AND\" , [ \"A\" , \"B\" , \"OUT\" ], {})","title":"Creating a subcircuit"},{"location":"elements/circuit/#global-circuit","text":"There is a global circuit called netlist that exists within nimphel.","title":"Global circuit"},{"location":"elements/circuit/#dependency-graph","text":"graph = netlist . to_graph () generate_graph ( graph )","title":"Dependency graph"},{"location":"elements/circuit/#number-of-instances","text":"netlist . coutn_instances ()","title":"Number of instances"},{"location":"elements/component/","text":"Creation of components Creation of a simple Resistance class R ( Component ): def __init__ ( self , ports , params = None ): defaults : Params = { \"R\" : 1e3 } user_params = dict ( params ) if params else {} super ( R , self ) . __init__ ( ports , { ** defaults , ** user_params }, name = \"Res\" ) def fmt ( self ) -> str : def fmt_net ( net ): return f \"net { net } \" if isinstance ( net , int ) else net ports = \" \" . join ( map ( fmt_net , self . ports )) return f 'R { self . num_id } ( { ports } ) R { self . params [ \"R\" ] } ' A component may implement an additional method called fmt() . This method accepts no argument and should return the string representation of the component. Wrapper for simple components The process of creating multiple simple components can be tedious. The wrapper @simple_component allows to create components similarly to a dataclass. @simple_component class C ( Component ): name : \"Capacitor\" letter : \"C\" defaults : Params = { \"C\" : 1e3 , \"T\" : None } Component models A model allows to reuse a component name and a set of parameters across multiple definitions. Creation of a NMOS model NMOS = Model ( name = \"nmosfet\" , params = { \"w\" : 0.135 , ... }, ) @simple_component class NMosfet ( Component ): model = NMOS class NMosfet ( Component ): def __init__ ( self , ports , params = None , name = None ): parameters = params if params else {} super ( Mosfet , self ) . __init__ ( ports , parameters , model = NMOS , name = name ) Serialization and deserialization Components can be serialized to a dict by using the to_dict() method. To serialize to JSON, use the to_json() method. Example of serializing and deserialization mosfet = NMosfet ([ \"in\" , \"out\" , GND , VDD ]) comp_dict = mosfet . to_dict () json_str = mosfet . to_json () assert mosfet == NMosfet . from_json ( json_str )","title":"Components"},{"location":"elements/component/#creation-of-components","text":"Creation of a simple Resistance class R ( Component ): def __init__ ( self , ports , params = None ): defaults : Params = { \"R\" : 1e3 } user_params = dict ( params ) if params else {} super ( R , self ) . __init__ ( ports , { ** defaults , ** user_params }, name = \"Res\" ) def fmt ( self ) -> str : def fmt_net ( net ): return f \"net { net } \" if isinstance ( net , int ) else net ports = \" \" . join ( map ( fmt_net , self . ports )) return f 'R { self . num_id } ( { ports } ) R { self . params [ \"R\" ] } ' A component may implement an additional method called fmt() . This method accepts no argument and should return the string representation of the component.","title":"Creation of components"},{"location":"elements/component/#wrapper-for-simple-components","text":"The process of creating multiple simple components can be tedious. The wrapper @simple_component allows to create components similarly to a dataclass. @simple_component class C ( Component ): name : \"Capacitor\" letter : \"C\" defaults : Params = { \"C\" : 1e3 , \"T\" : None }","title":"Wrapper for simple components"},{"location":"elements/component/#component-models","text":"A model allows to reuse a component name and a set of parameters across multiple definitions. Creation of a NMOS model NMOS = Model ( name = \"nmosfet\" , params = { \"w\" : 0.135 , ... }, ) @simple_component class NMosfet ( Component ): model = NMOS class NMosfet ( Component ): def __init__ ( self , ports , params = None , name = None ): parameters = params if params else {} super ( Mosfet , self ) . __init__ ( ports , parameters , model = NMOS , name = name )","title":"Component models"},{"location":"elements/component/#serialization-and-deserialization","text":"Components can be serialized to a dict by using the to_dict() method. To serialize to JSON, use the to_json() method. Example of serializing and deserialization mosfet = NMosfet ([ \"in\" , \"out\" , GND , VDD ]) comp_dict = mosfet . to_dict () json_str = mosfet . to_json () assert mosfet == NMosfet . from_json ( json_str )","title":"Serialization and deserialization"},{"location":"elements/subcircuit/","text":"Creating a subcircuit Example of creating an inverter INV = Subckt ( \"INV\" , [ \"in\" , \"out\" ], {}) INV . add ( Mosfet ([ \"out\" , \"in\" , GND , GND ], name = \"nmos\" )) INV . add ( Mosfet ([ \"out\" , \"in\" , VDD , VDD ], name = \"pmos\" )) INV . fix () # Prevents the subcircuit of adding more components Instanciating a subcircuit A subcircuit can be instanciated by usig the 'inst()' method. This method takes the same arguments as Component . Instanciating an inverter inv = INV . inst ([ \"input\" , net ()], {})","title":"Subcircuits"},{"location":"elements/subcircuit/#creating-a-subcircuit","text":"Example of creating an inverter INV = Subckt ( \"INV\" , [ \"in\" , \"out\" ], {}) INV . add ( Mosfet ([ \"out\" , \"in\" , GND , GND ], name = \"nmos\" )) INV . add ( Mosfet ([ \"out\" , \"in\" , VDD , VDD ], name = \"pmos\" )) INV . fix () # Prevents the subcircuit of adding more components","title":"Creating a subcircuit"},{"location":"elements/subcircuit/#instanciating-a-subcircuit","text":"A subcircuit can be instanciated by usig the 'inst()' method. This method takes the same arguments as Component . Instanciating an inverter inv = INV . inst ([ \"input\" , net ()], {})","title":"Instanciating a subcircuit"}]}